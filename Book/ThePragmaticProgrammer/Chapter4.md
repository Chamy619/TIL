# 4장. 실용주의 편집증

**소제목**

21. 계약에 의한 설계
22. 죽은 프로그램은 거짓말을 하지 않는다.
23. 단정적 프로그래밍
24. 언제 예외를 사용할까
25. 리소스 사용의 균형



"완벽한 소프트웨어는 만들 수 없다." 라는 말로 이번 장이 시작한다. 지금까지 누구도 만든 적 없었고, 현재 누구도 만들 수 없는 것으로 보이기 때문에 우리는 방어적으로 프로그래밍 해야 한다.

어디서 문제가 발생할지 모르기 때문에 문제 발생 상황을 대비해야 한다.



# 21. 계약에 의한 설계

루틴을 실행 할 때 2가지의 상태가 있다.

* 선행 조건
* 후행 조건

선행 조건은 루틴이 실행되기 전에 참이어야 하는 조건들이다. 해당 조건이 아니면 루틴은 실행되지 않는 다는 것을 보장해야 한다.

후행 조건은 루틴의 실행 결과로 바뀌는 값들이다. 루틴의 실행 결과는 예측 가능해야한다.



# 22. 죽은 프로그램은 거짓말을 하지 않는다.

문제가 발생했을 때, 이를 안고 계속 실행되는 것보다 프로그램을 죽이는 것이 도움이 될 때가 많다. 이를 안고 가는 것은 이후 동작들도 신뢰할 수 없는 것이 되고, 결국 프로그램을 망치게 될 것이다.

문제가 발생한 곳에서 최대한 빨리 프로그램을 멈춰 해결 방안을 생각해보자.



# 23. 단정적 프로그래밍

`assert`문을 사용해 코드의 신뢰성을 높이자.



# 24. 언제 예외를 사용할까

try catch 문을 사용하면 예외를 한 곳에서 몰아서 처리하기 때문에 프로그램의 동작 순서를 더 쉽게 파악할 수 있다. 

반드시 해당 조건이 수행되어야 할 경우 예외 처리를 사용하라. 그리고 있어도 되고, 없어도 되는 경우라면 예외 처리 대신 일반문을 사용하라.



# 25. 리소스 사용의 균형

리소스를 해제하는 가장 핵심적 원칙은 사용한 곳에서 해제하는 것이다. try catch finally 문을 사용해 finally에서 리소스를 해제하면 된다.

먄약 finally를 지원하지 않는 언어의 경우 포인터 대신 다른 값을 사용하거나, 클래스로 변형해서 사용하면 된다.

C++, C 또는 Java에서 메모리를 해제했을 경우 포인터 또는 객체의 값을 null로 처리하는 것은 좋은 프로그래밍 방법이다. 이후에 null 체크를 통해 존재하지 않는 메모리에 접근하는지 확인할 수 있기 때문에 찾기 어려운 에러를 발견하기 쉽게 도와준다.