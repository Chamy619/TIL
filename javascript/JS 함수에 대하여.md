# JS: 함수에 대하여

"인사이드 자바스크립트" 책을 구입해서 읽던 중 4장 제목이 함수와 프로토타입 체이닝인데 몰랐던 부분이 많고, 정리해두면 좋을 것 같아서 글을 쓰게 되었다. 

# 함수 정의

함수는 세 가지 방법으로 정의할 수 있다.

* 함수 선언문
* 함수 표현식
* Function() 생성자 함수

자바스크립트에서는 함수도 객체이다. 그래서 조금 어색하지만 변수에 함수의 레퍼런스를 담을 수 있고, 객체를 리터럴로 생성하듯 함수도 리터럴로 생성할 수 있다.



## 함수 선언문

```javascript
function add(a, b) {
    return a + b;
}
```

위의 코드가 함수 리터럴 방식이자 함수 선언문 방식이다. 사실 리터럴 방식과 함수 선언문은 약간의 차이점이 존재하는데, 리터럴은 함수 이름이 선택사항이다. `add` 라는 이름이 없어도 리터럴 방식이라고 할  수 있다. 하지만 함수 선언문은 반드시 이름이 있어야하고, 만든 이름으로 함수에 접근한다.



## 함수 표현식

```javascript
var add = function (a, b) {
    return a + b;
}
```

정확히 표현하면 여기서 오른쪽 항에 있는 부분이 함수 리터럴이다. 함수 리터럴의 레퍼런스를 `add` 변수에 담아 함수 표현식으로 함수를 생성한다. 함수 리터럴로 만든 함수는 이름이 없기 때문에 익명 함수라고 부르고, `plus = add` 처럼 익명 함수 레퍼런스를 다른 변수에도 담을 수 있다.

위의 예제는 익명함수로 만들었기 때문에 익명 함수 표현식이라고 부른다. 만약 오른쪽 함수 리터럴에 이름을 넣어 줬을 때는 기명 함수 표현식이다. 기명 함수를 사용할 때 주의할 점이 있다.

```javascript
var add = function sum(a, b) {
    return a + b;
}
```

위의 예제에서 만약 두 수를 더할 때 `add` 와 `sum` 중 어떤 것을 사용해야할까? 나는 처음에 둘 다 사용해도 될 줄 알았다. 하지만 `sum(1, 3)` 을 호출하면 아래 사진처럼 에러가 발생한다.

![image-20210731152843701](C:\Users\양채훈\AppData\Roaming\Typora\typora-user-images\image-20210731152843701.png)

오른쪽에 `sum` 이라는 이름으로 선언된 함수는 외부에서 `sum` 으로 접근이 불가능하다. 그럼 여기서 생기는 의문점은 "이름을 쓸 필요가 없는건가?" 이다. 기명 함수 표현식을 사용할 때는 내부에서 재귀적으로 자기 자신을 호출할 때다. 사실 외부에서만 `sum` 사용이 불가능하고, `sum` 함수 내부에서는 `sum` 으로 접근이 가능하다.

시작 수부터 끝 수까지 모두 더하는 함수는 아래 코드처럼 만들 수 있다.

```javascript
var add = function sum(a, b) {
    if (a === b) {
        return a;
    }
    return a + sum(a + 1, b);
}
```

외부에서는 `sum` 에 접근하지 못하지만, `sum ` 함수 내부에서는 `sum` 에 접근할 수 있다. 이렇게 재귀적인 함수를 생성해야 할 때는 기명함수를 사용해서 내부에서 자신에게 접근할 수 있다.

## Function() 생성자 함수

```javascript
var add = new Function('a', 'b', 'return a + b');
```

이 방법은 자주 사용되는 문법은 아니다. `new Function` 형태로 객체를 생성하는 방식으로 함수를 생성하고(함수도 객체이므로) 가장 마지막엔 동작, 이 전에는 매개변수들이 들어온다.



## 정리

그럼 위의 세 가지 방법 중 가장 좋은 함수 생성법은 무엇일까? 물론 각각의 장단점이 있을 수도 있지만, 함수 호이스팅의 변수를 제거하기 위해서는 함수 표현식을 사용하는 것이 좋다. 함수 선언식의 방식으로 함수를 생성하면 호이스팅이 일어나서 선언하기 전에도 해당 함수에 접근할 수 있다. 하지만 함수 표현식을 사용하게 되면 해당 위치에서 함수가 정의되기 때문에 호이스팅으로 인한 실수를 최소화할 수 있다.

