# TIL

하루하루 공부한 것을 적어봅시다.

## 2021.01.30 - 2021.03.05

### 엘리의 드림코딩으로 javascript ES6 기본기 공부

- <a href="./javascript/자바스크립트의역사.md">자바스크립트의 역사</a>
- <a href="./javascript/async와difer.md">async와 difer</a>
- <a href="./javascript/데이터타입과let,var,hoisting.md">데이터 타입과 호이스팅</a>
- <a href="./javascript/operator,if,for.md">연산자와 조건문 및 반복문</a>
- <a href="./javascript/function.md">함수</a>
- <a href="./javascript/class.md">클래스</a>
- <a href="./javascript/object.md">객체</a>
- <a href="./javascript/array.md">배열</a>
- <a href="./javascript/json.md">JSON</a>
- <a href="./javascript/callback.md">콜백함수</a>
- <a href="./javascript/promise.md">Promise</a>
- <a href="./javascript/async.md">async와 await</a>

### CodeComplete 책

- <a href="./Book/CodeComplete/Chapter4.md">4장 구현 시 결정해야 할 핵심 사항</a>
- <a href="./Book/CodeComplete/Chapter5.md">5장 구현 설계</a>
- <a href="./Book/CodeComplete/Chapter6.md">6장 클래스 다루기</a>
- <a href="./Book/CodeComplete/Chapter7.md">7장 고급 루틴</a>
- <a href="./Book/CodeComplete/Chapter8.md">8장 방어적 프로그래밍</a>
- <a href="./Book/CodeComplete/Chapter9.md">9장 의사코드 프로그래밍 프로세스</a>
- <a href="./Book/CodeComplete/Chapter10.md">10장 변수 사용 시 고려할 사항</a>
- <a href="./Book/CodeComplete/Chapter11.md">11장 변수 이름의 기능</a>
- <a href="./Book/CodeComplete/Chapter12.md">12장 기본 데이터형</a>
- <a href="./Book/CodeComplete/Chapter13.md">13장 특이한 데이터형</a>
- <a href="./Book/CodeComplete/Chapter14.md">14장 순차적 코드 구성하기</a>
- <a href="./Book/CodeComplete/Chapter15.md">15장 조건문 사용</a>
- <a href="./Book/CodeComplete/Chapter16.md">16장 반복문 제어</a>
- <a href="./Book/CodeComplete/Chapter17.md">17장 특이한 제어구조</a>
- <a href="./Book/CodeComplete/Chapter18.md">18장 테이블 활용 기법</a>
- <a href="./Book/CodeComplete/Chapter19.md">19장 제어와 관련된 일반적인 이슈</a>

### React

#### Docs 개념 보며 따라하기

- <a href="./react/Docs/helloworld.md">Hello world</a>
- <a href="./react/Docs/JSX.md">JSX</a>
- <a href="./react/Docs/엘리먼트렌더링.md">엘리먼트 렌더링</a>
- <a href="./react/Docs/Component와 Props.md">Component와 Props</a>
- <a href="./react/Docs/State and Lifecycle.md">State와 생명주기</a>
- <a href="./react/Docs/이벤트 처리하기.md">이벤트 처리하기</a>
- <a href="./react/Docs/조건부렌더링.md">조건부 렌더링</a>
- <a href="./react/Docs/리스트와 key.md">리스트와 키</a>
- <a href="./react/Docs/폼.md">Form</a>
- <a href="./react/Docs/State 끌어올리기.md">State 끌어올리기</a>
- <a href="./react/Docs/합성(Composition) vs 상속(Inheritance).md">합성 vs 상속</a>
- <a href="./react/Docs/React로 사고하기.md">리액트로 사고하기</a>

#### Tutorial

- <a href="./react/Tutorial/튜토리얼.md">튜토리얼 추가기능 구현하기</a>

<hr>

## 2021.03.06

**<a href="./Book/CodeComplete/Chapter20.md">코드 컴플리트 20장 소프트웨어 품질</a>**

소프트웨어 품질 보증 활동은 제품 생산 전 과정에 걸쳐서 중요함
제품 생산 과정 중 오류를 찾아 수정하는 시간이 가장 길기 때문에 이 시간을 줄이는 것이 제품 생산 비용을 낮추는데 큰 역할을 하고, 품질 보증 활동은 이 부분에 특히 효과적임

**OKKYCON 2021: 협력의 기술**

팀원들의 커뮤니케이션 능력을 향상시키기 위해서는, 그리고 팀에 좋은 개발 문화를 정착시키기 위해서는 자신의 의견이 무시되거나, 놀림거리 또는 질책의 대상이 되지 않을 것이라는 심리적 안정감을 주는 것이 중요하다.

라인에서 오신 분이 API 자동화에 대해 강의하신 내용은 다시보기로 한번 더 봐야겠다.

**Momentum 클론코딩 시작**

<hr>

## 2021.03.07

**<a href="./Book/CodeComplete/Chapter21.md">코드 컴플리트 21장 협력 구현</a>**

정밀 검토 또는 짝 프로그래밍을 할 경우 소프트웨어의 품질을 향상시킬 수 있고, 시니어 개발자의 경험과 스킬을 주니어 개발자에게 전달해 줄 수 있다. 이를 통해 팀 전체의 생산성 향상도 기대할 수 있다.

**Momentum Time 컴포넌트 수정**

<hr>

## 2021.03.08

**Momentum Component 구조**

<img src="./images/momentum컴포넌트구조.JPG" alt="Momentum component 구조"/>

컴포넌트 이름

- 빨강: Mementum
- 주황: Weather
- 보라: Time
- 노랑: SearchBar
- 연두: Lists
- 초록: TodoList
- 남색: Todo
- 하늘: DoneList
- 파랑: Done

이렇게 컴포넌트가 구성되어 있다(보라가 중간에 껴있는 것은 이해 바람).

**Momentum SearchBox input 값 상위 컴포넌트로 올리기**

SearchBox 컴포넌트 내의 input 값을 Momentum 컴포넌트에서 관리할 수 있도록 SearchBox와 Momentum 컴포넌트 모두 class형 컴포넌트로 수정.
Momentum 컴포넌트에서 SearchBox의 input 값을 받는 inputValue state를 생성하였고, input의 값을 전달하기 위해 SearchBox에서도 value state를 생성.
SearchBox 컴포넌트에서 폼을 생성해 Submit을 할 수 있도록 하였고, submit 할 경우 input의 값을 빈 값으로 초기화.

<hr>

## 2021.03.09

**JS Number.toFixed()**

Number 객체의 toFixed 메서드는 지정한 값 만큼의 소수점만 보여줌.

사용법

```javascript
const str = Number(10.565).toFixed(2);
console.log(str); // 10.56
```

toFixed 메서드를 사용해 소수점 둘째 자리 까지만 보이도록 설정한 값을 출력하면 10.565가 10.56으로 출력되고, str의 타입은 string이다.

**JS Form submit 이벤트 발생 시 자식 노드에 접근하기**

form submit 이벤트만으로 자식 노드인 input의 값에 접근하기 위해서는 이벤트 핸들러에서 `event.target.childNodes[0].value`로 접근하면 된다.

자식의 수에 따라 childNodes의 번호는 바뀔 수 있고, event.target은 form 그 자체를 가리킨다.

**Momentum TodoList 생성**

사용자로부터 받은 입력으로 하나씩 추가해가는 배열을 state로 설정하고, 이 값을 TodoList 컴포넌트에 전달

<hr>

## 2021.03.10

**CSS display inline-block과 float left**

두 개의 높이가 다른 div를 `display: inline-block`으로 설정할 경우

<img src="./images/inline.JPG" alt="display: inline-block;" />

`float: left`로 설정할 경우

<img src="./images/float.JPG" alt="float: left;" />

두 사진을 비교해보면 inline-block의 경우 아래가 서로 맞춰지고, float left의 경우 위가 서로 맞춰지는 것을 볼 수 있다. 위를 맞출지, 아래를 맞출지를 기준으로 두 가지를 나눠 사용하면 될 것 같다.

**Momentum TodoList, DoneList 컴포넌트 상하 -> 좌우로 보이도록 css 설정**

<hr>

### 2021.03.11

**window.print()로 페이지 인쇄시 차트 테이블 잘리는 문제 해결 방안**

css 속성에 `break-inside`를 추가해주면 되는데 나는 아래와 같이 해결했다.

```css
.pageBreak {
  break-inside: avoid;
  break-after: auto;
}
```

위의 속성을 주면 페이지 하단에서 내용이 잘리는 경우 자동으로 아래 페이지에서 출력하도록 지원해준다.

**CSS: break-inside**

인쇄시 페이지가 잘리는 break point는 이전 element의 `break-after`, 다음 element의 `break-before`, 현재 속한 container의 `break-inside`의 값에 영향을 받는다.

break의 우선 순위는 먼저 등장한 것 우선이다. 한 element 내에서는 `break-before` > `break-inside` > `break-after` 순으로 우선 순위가 적용된다.

break-inside가 가질 수 있는 properties

- `auto`
  - default 값으로, break를 허용할 수도 있고, 허용하지 않을 수도 있음.
- `avoid`
  - 어느 종류의 break든 이를 최대한 피함
- `avoid-page`
  - page break를 최대한 피함
- avoid-column
  - column break를 최대한 피함
- avoid-region
  - region break를 최대한 피함

또한 `break-inside`는 이전 `page-break-inside`와의 호환성을 보장

**git rebase**

Git에서 branch를 병합하는 방법은 merge와 rebase가 있는데 merge의 경우 안전하고, 쉽다. 그냥 `git merge hotfix`처럼 입력하면 충돌이 생기면 충돌이 생겼다고 알려주고, 충돌이 없을 경우 완전히 merge 된다. 하지만 한 branch에서 여러 개의 커밋을 한 개로 묶고 싶을 경우 merge로는 이를 할 수 없다(내가 알기로는).

여기서 도움이 되는 것이 `git rebase`다. rebase를 하면 합치고 싶은만큼 커밋을 합쳐서 하나로 만들고, 이를 병합하려는 branch의 head에 가져다 놓을 수 있다.

```bash
$ git checkout hotfix
$ git rebase -i @~5     // 최근 5개의 커밋을 합침
```

위를 실행하면 아래와 같은 창을 볼 수 있을 것이다.

```bash
pick a03c578 initial commit
pick d587ff3 헤더 수정
pick f3f5f1f hotfix 수정
pick c30397a 테스트
pick e795cd1 완료

# Rebase a03c578..e795cd1 onto a03c578
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
```

위는 vi로 열리는데 가장 위의 initial commit의 pick은 고정이고, 아래부터 pick을 하단의 커맨드 중 원하는 것으로 바꿔주면 되는데, 커밋을 하나로 합치고 싶은 경우라면 s로 바꿔주면 된다.

이후 `:wq`로 나가면 또 한번 vi가 열린다.

```bash
# This is a combination of 5 commits.
# The first commit's message is:
initial commit

# This is the 2nd commit message:

헤더 수정

# This is the 3rd commit message:

hotfix 수정

# This is the 4th commit message:

테스트

# this is the 5th commit message:

완료

```

여기서는 이제 자기가 원하는 커밋 메시지를 작성하면 되는데 `dd` 명령을 사용하면 한 줄을 삭제할 수 있다.

이제 이후 master branch로 checkout 한 다음, merge를 진행하면 5개의 커밋 메시지가 삽입되는 대신, 한 개의 커밋 메시지가 삽입된다.

<hr>

## 2021.03.12

### Docker 현재 컨테이너 상태 원격에 푸시하기

**Docker 컨테이너 커밋하기**

`docker commit {CONTAINER} {IMAGE}` 명령을 사용해 컨테이너의 상태를 이미지로 커밋할 수 있다.

```bash
$ docker commit myContainer centos7
```

**Docker 이미지 푸시하기**

현재 이미지를 원격 저장소에 올리기 위해서는 푸시를 해야한다.

1. `docker login`으로 일단 도커에 로그인 한다.
2. `docker tag {IMAGE} {TAG}`로 이미지에 태그를 단다.
3. `docker push {TAG}`로 푸시를 한다.

```bash
$ docker login
$ docker tag centos7 chamy/centos7
$ docker push chamy/centos7
```

현재 컨테이너의 상태를 원격 저장소에 푸시하기 위해서는 크게 3개의 단계를 거친다.

1. 컨테이너의 상태를 이미지로 커밋
2. 이미지에 태그 달기
3. 태그단 이미지를 푸시

**JS Array.filter 메서드**

JS에서 Array.filter 메서드를 사용하면 배열에서 원하는 조건만 출력할 수 있음

```javascript
const array = [0, 1, 2, 3, 4, 5];

const even = array.filter(value = > value % 2 === 0);

console.log(even);
```

위처럼 사용하면 array의 요소 중 2로 나눴을 때 나머지가 0인 값들만 걸러지고, 걸러진 배열을 출력하므로 [0, 2, 4]가 출력된다.

정리하면, filter를 사용하면 콜백 함수가 호출되고, 콜백함수로 전달되는 값은 배열의 각 원소들이다. 그리고 콜백 함수가 리턴하는 값을 배열 형태로 반환한다.

**Momenum Todo 클릭시 삭제 기능 추가**

<hr>

## 2021.03.13

**<a href="./Book/CodeComplete/Chpater22.md">코드 컴플리트 22장 개발자 테스트</a>**

테스트 주도 개발(TDD)의 장점에 대해 알게 되었다. 그동안 TDD에 관심이 그렇게 크지 않았는데 여기에 대해 공부해보고 싶은 마음이 생겼고, 개인적으로 테스트 기록을 남겨 이후에 참고할 수 있도록 해야겠다.

**Mometum TodoList에 존재하는 항목 추가시 이미 존재합니다 메시지 출력 기능 구현**

입력으로 받은 값이 todoList state 배열에 존재하는지 Array.indexOf 메서드를 사용해 판단하고, 존재하지 않을 경우 배열에 추가하고, 존재할 경우 추가하지 않고, 화면에 경고 메시지를 띄우도록 함.

```javascript
handleSubmit(value) {
  const todoList = this.state.todoList;

  if (todoList.indexOf(value) === -1) {
    todoList.push(value);
    this.setState({
      inputValue: value,
      todoList: todoList,
      alreadyExist: false
    });
  } else {
    this.setState({
      alreadyExist: true
    });
  }
}
```

<hr>

## 2021.03.14

**<a href="./Book/CodeComplete/Chapter23.md">코드 컴플리트 23장 디버깅</a>**

그동안 console.log로만 디버깅해왔던 내 자신을 반성하게 된다. 오류가 발생하게 된 원인을 명확히 찾고, 프로그램을 이해한 후 결함을 수정할 수 있는 개발자가 되어야겠다.

**JS Drag and Drop**

드래그를 위해서는 드래그 하려는 태그에 draggable="true" 속성을 주어야 하고, ondragstart와 ondrag 이벤트 핸들러를 작성해야 한다.

드랍을 위해서는 드랍을 하려는 태그에 droppable="true" 속성을 주어야 하고, ondrop과 ondropover 이벤트 핸들러를 작성해야 하는데, 이 부분은 조금 더 공부한 후 정리해서 올려야겠다.

<hr>

## 2021.03.15

**Momentum Todo 컴포넌트에 드래그 기능 추가**

<hr>

## 2021.03.16

**JS window.open**

JS에서 `wondow.open(URL)`을 입력하면 URL 주소의 새 창을 띄운다. 이때 한 번 더 `window.open(URL)`로 이전과 같은 URL을 띄울 때는 새 창이 뜨지 않고, 이전의 창이 다시 나타난다(창이 2개가 아니라 1개라는 뜻).

```javascript
const url = "https://tistory.com";
window.open(url);
window.open(url);
```

만약 같은 URL로 여러 개의 새 window를 띄우고 싶다면, 두 번째 파라미터인 name을 설정해주면 된다.

```javascript
const url = "https://tistory.com";
window.open(url, 1);
window.open(url, 2);
```

위 처럼 두번째 파라미터에 다른 값을 입력하면 다른 창이 뜨고, 만약 `window.open(url, 1)`을 한번 더 실행할 경우에는 기존에 떠있던 1번 창이 위로 보여지게 된다.

**Momentum Todo 항목 Done List로 이동시키는 기능 추가**

Drag and Drop을 사용해 Todo 항목을 Done List로 이동시키는 기능을 추가했다. TodoList 컴포넌트에 dragStart 이벤트를 추가하고, DoneList 컴포넌트에 onDrop 이벤트를 추가하고, onDragOver를 동작 중지시켜 구현했다.

Todo 컴포넌트 요소들은 각각 자기의 이름을 id로 가지고 있고, 이는 어떤 항목을 드래그했는지 알게하기 위함이다.

드래그를 시작할 때 dragStart 이벤트가 발생하고, 여기에 `event.dataTransfer.setData('targetId')`를 설정해, 드래그 이벤트가 진행되는 동안 어떤 id를 드래그 중인지 설정해 놓는다. 이후 onDrop 이벤트가 발생하게 되면 해당 이벤트 핸들러에서는 `event.dataTransfer.getData('targetId')`를 통해 드래그 된 항목의 id를 가져온 후 이를 처리한다.

Done List에 항목을 이동시켰으면 Todo List에서는 빼야한다. 이를 처리하기 위해 removeTodo 메서드를 DoneList 컴포넌트에도 전달해 onDrop 이벤트 핸들러에서 이를 처리하도록 했다.

**React 클래스형 컴포넌트 내의 메서드에서 this를 사용한다면 생성자에 꼭 this 바인딩을 해주자**

클래스형 컴포넌트 내의 메서드에서 props나 state를 사용할 때는 this를 사용하는데, 이때 생성자에서 this를 바인딩 해주지 않으면 에러가 발생한다.

<hr>

## 2021.03.17

**Momentum material UI 추가**

```bash
// material-ui 설치
$ npm install @material-ui/core

// material-ui 적용
$ yarn add @material-ui/core

// 애플리케이션 패키지 재설치
$ npm install
```

세 단계를 거쳐 현재 Momentum 앱에 material-ui를 등록했고, 테스트 결과 버튼을 무난히 띄울 수 있었다.

현재 문제는 input 태그에 material-ui를 적용하면 이벤트 핸들러를 어떻게 작성해야 하는가다. 이번 주 남은 기간은 material-ui를 배우고 삽질하는데 많은 시간이 쓰일 것 같다.

<hr>

## 2021.03.18

**CSS에서 클릭 이벤트 제거**

만약 클릭 이벤트를 CSS에서 제거하고 싶을 때는 `point-events: none`을 주면 된다.

**<a href="/react/Experience/state_undefined.md">React state를 생성할 때 undefined일 경우</a>**

상의 컴포넌트로부터 props로 받은 값이 undefined 값이고, 이를 state로 선언할 경우 해당 state는 생성되지 않는다.

**Momentum material UI에 이벤트 핸들러 등록**

<hr>

## 2021.03.19

**Momentum TodoList, DoneList CSS 적용**

<hr>

## 2021.03.20

**Momentum 배경 사진 API 적용**

**웹 페이지에 px을 사용하지 말자**

<hr>

## 2021.03.21

**JS 위도 경도 가져오기**

```javascript
navigator.geolocation((position) => {
  const latitude = position.coords.latitude;
  const longitude = position.coords.longitude;
});
```

navigator의 geolocation 메서드를 사용하면 위도와 경도 정보를 가져올 수 있음

<hr>

## 2021.03.22

**JS 위도 경도로 카카오 API 사용해 현재 위치 표시하기 - 실패**

unauthrized 메시지를 리턴 받는데, 키를 제 위치에 넣지 못한 것 같다. 내일 다시 시도해보고, 사용법을 정리해서 올려야겠다(생각보다 친절히 설명된 것을 찾기 힘듬).

<hr>

## 2021.03.23

**크롬 모달 scrollIntoView 이슈**

오늘 테이블을 클릭하면 해당 차트로 스크롤이 이동하는 동작을 만드는 작업을 하던 중 scrollIntoView 사용시 body와 모달이 동시에 스크롤되는 현상이 발생했다. 모달만 스크롤되고 body만 스크롤 하기 위해서 body에서 스크롤 이벤트가 발생하면, `scrollTop(0)`을 사용해 스크롤 이벤트를 막고 모달만 스크롤 되도록 설정했다.

여기서 크롬에서는 동작하지 않고, 파이어폭스에서는 동작하는 것이

```javascript
$("#element").scrollIntoView({ behavior: "smooth" });
```

위의 코드였다. `behavior smooth`속성을 주면 파이어폭스에서는 body는 스크롤되지 않고, 모달만 스크롤되지만, 크롬에서는 body와 모달 모두 스크롤되지 않는다. 그래서 behaivor 속성을 없애고 실행하면 파이어폭스와 크롬 모두 body는 스크롤되지 않고, 모달만 스크롤된다.

이번 이슈를 해결하면서 내린 결론은 크롬에서 scrollIntoView를 실행할 때 smooth 속성을 준다면 부모 -> 자식으로 가면서 동작이 성공해야 다음 동작이 진행되는 것을 알게되었다. 실제로 `$('body').scrollTop(0)`을 주지 않고, smooth 속성의 scrollIntoView 이벤트를 발생시켰을 때, body가 먼저 스크롤 된 후 모달이 스크롤된다.

**CSS body 스크롤 막는 방법과 한계**

CSS 설정으로 body의 스크롤을 막을 수 있다.

```css
body {
  height: 100%;
  overflow: hidden;
}
```

위처럼 height를 100%, overflow를 hidden으로 설정하면 body에서 스크롤을 할 수 없다.

하지만 scrollIntoView와 같은 다른 스크롤 이벤트로는 body가 스크롤되는데, 여기서 근본적인 문제는 body 내부에 body보다 더 긴 컴포넌트가 있을 때 스크롤이 된다. body 내부의 모든 컴포넌트가 body보다 작으면 당연히 스크롤될 것이 없기 때문에 scroll 되지 않는데, body 내부가 body보다 길어지면 문제가 발생한다.

<hr>

## 2021.03.24

**모멘텀 Kakao 로컬 API를 사용해 현재 위치 화면에 뿌리기**

그저께 실패한 이유가 로컬 API를 사용할 때는 REST API 키를 사용해야 하는데, 나는 Javascript 키를 사용해서 인증 에러가 났었다.

fetch를 사용해 카카오 api로 보내는 형태는 아래와 같다.

```javascript
fetch(`https://dapi.kakao.com/v2/local/geo/coord2regioncode.json?input_coord=WGS84&output_coord=WGS84&y=${latitude}&x=${longitude}`, {
  headers: {
    Authorization: `KakaoAK ${REST API Key}`
  }
});
```

위를 보내면 응답을 성공했다는 메시지를 받게 되는데, 이를 `json()`을 거쳐야 원하는 json 데이터를 얻을 수 있다. 방법은 아래와 같다.

```javascript
fetch("...").then(response.json()).then(console.log);
```

마지막 then에서 받은 값을 위치 데이터로 사용할 수 있다. 나는 위치 정보를 함수 컴포넌트에서 뿌리려고 했는데, 함수형 컴포넌트 내에서는 값의 변화를 외부 props로 받아야 하기 때문에 초기값인 '위치를 찾을수 없습니다' 에서 fetch를 통해 비동기적으로 통신을 완료했을 때 화면에 렌더링하는 loc 변수에는 현재 주소가 있지만 실제로 화면에 렌더링 되지는 않는 문제가 발생했다.

이 문제를 해결하기 위해서 날씨 컴포넌트를 클래스형 컴포넌트로 바꾸고, loc을 state로 관리하도록 했다. 그리고 `componentDidMount`를 사용해 컴포넌트가 렌더링 될 때, API 통신을 하고, 결과를 loc state에 반영했다.

<hr>

## 2021.03.25

**원티드 [성장하는 프론트엔드 개발자 되기] 참석**

> 성장하기 위한 좋은 방법 중 하나는 오픈 소스를 분석하는 것이다.

오픈 소스를 사용은 하지만, 분석해 본 적이 없었다. 그냥 어려울 것 같다는 느낌? 그런데 오늘 이야기를 들어보니 그렇게 어려운게 아닐지도 모른다는 생각이 들었다. 정말 뛰어난 개발자들이 좋은 설계를 적용한 코드를 볼 수 있고, 라이브러리 같은 것들은 규모가 그렇게 크지도 않기 때문에 당장 시작하고 싶은 마음이 생겼다.

**이미지 base64 인코딩**

오늘 이미지 파일을 base64로 인코딩해서 사용하는 것을 해봤는데 그냥 글자가 이미지 그 자체라는게 신기했다. 그 글자들을 웹 주소창에 치면 진짜 그 이미지가 나온다. 원리에 대해 좀 더 공부하고 싶어졌다.

<hr>

## 2021.03.26

**크롬에서 window.open resizable**

크롬에서 윈도우 창을 새로 열 때 resizable은 동작하지 않는다. Only IE 라고 되어있는 것으로 보아 인터넷 익스플로어에서만 동작하는 것 같다.

**모멘텀 todo, done 항목에 hover css 추가**

CSS의 hover를 사용해 마우스를 todo와 done 위에 두면 배경 색이 변하고, 커서도 손가락으로 변하는 기능 추가

<hr>

## 2021.03.27

**<a href="./Book/CodeComplete/Chapter24.md">코드 컴플리트 24장 리팩터링</a>**

리팩터링은 유지보수 단계에서만 하는 것이 아니다. 오히려 릴리즈 하기 전이 리팩터링하기 더 좋은 타이밍이다. 지금 내가 잡은 코드보다 더 나은 품질을 갖도록 하는 것이 리팩터링이다. 단순히 코드를 변경하는 것이 리팩터링이 아니다!

**모멘텀 CSS 개선**

일단 TodoList 컴포넌트와 DoneList 컴포넌트에 중복적으로 적용되는 css가 있어서 이 둘의 클래스를 `list todoList`와 `list doneList`로 바꾸고, 중복 적용 사항은 `.list`에서 정의하고, 별도 적용 사항은 `.list.todoList`와 `.list.doneList`에서 적용했다. 또한 Todo 컴포넌트와 Done 컴포넌트 역시 현재 동일한 css를 중복해서 적용하고 있어서 content 클래스로 묶어서 해당 클래스로 css를 적용했다.

모멘텀의 날씨 컴포넌트에 `text-align: right`을 줘서 화면의 오른쪽에 표시하도록 했고, 기존 px 단위 표현을 rem으로 변경했다.

Input materia ui 컴포넌트의 width를 100%로 설정하고, 텍스트를 입력할 때 가운데에서 입력되도록 변경했는데, width를 100%로 설정하는 아래처럼 fullWidth=true를 주면 된다.

```javascript
<Input fullWidth={true}>
```

다음으로 text-align을 center로 하는 건데, 이는 inputProps로 style을 넘겨주면 된다.

```javascript
<Input inputProps={{style: {textAlign: 'center'}}}>
```

우리가 사용하는 Input 컴포넌트는 div 안에 input 태그가 들어간건데, 위처럼 style을 전달하면 div 내부의 input 태그의 스타일에 적용된다. div에는 전달되지 않으므로, 여기에 width를 아무리 바꿔도 width가 변경되지 않는다(div 내부에 속해있으므로, div의 width를 먼저 바꿔야 함).

<hr>

## 2021.03.28

**코드 컴플리트 25장 코드 튜닝 전략**

다음 장을 읽어봐야 하겠지만, 코드 튜닝은 나에게는 조금 먼 이야기라고 느껴졌다. "아직 동작을 구현하기도 조금 벅찬데 효율성을 위해서 지금 코드를 보기는 어렵지만 더 효율적인 코드로 바꿔야할 수 있을까?" 라는 생각이 든다.

이 장에서는 코드 튜닝이 항상 더 좋은 코드는 아니고, 코드 튜닝보다 컴파일러 및 하드웨어를 교체하거나, 설계 부분에서 문제를 찾는 것이 더 효율적일 수 있다고 한다. 다음 장에서 코드 튜닝 방법에 대해 조금 더 읽어보고 적용할 수 있는 문제인지 확인해야겠다.

<hr>

## 2021.03.29

**CSS position absolute와 부모와의 관계**

개체의 위치를 div 태그 내의 가운데에 고정시키기 위해서 `position: absolute`와 `left: 50%`를 사용했는데 내가 원하는 곳이 아니라 전체 화면의 가운데에 위치해서 어떻게 내가 원하는 곳에 위치 시킬 수 있을까에 대해 찾아보다가, absolute가 부모 중 position이 relative, fixed, absolute 중 하나인 경우, 해당 부모 내의 절대 위치가 된다. 그래서 부모 div의 position을 relative로 주고, 해당 div의 자식의 position을 absolute, left를 50% 주면 부모의 가운데에 위치하게 된다.

<hr>

## 2021.03.30

모멘텀 사용자가 시간 표기법을 설정할 수 있는 기능 추가\*\*

<hr>

## 2021.03.31

**CSS flex**

기존 inline-block과 float을 사용하던 부분을 `display: flex`를 사용하면 조금 더 강력하게 화면을 구성할 수 있다는 것을 알게 되었다. 기능이 너무 강력하고 신기해서 나는 3 개의 div를 3등분해서 나눈 후 화면에 보여주고 싶었는데 flex를 사용하면 매우 쉽게 구현할 수 있었다. 조금더 flex와 grid에 대해 공부해보고, 나한테 더 잘 맞는 것을 사용해야겠다.

**모멘텀 CSS flex 적용 및 시간 표기법 설정 UI 수정**

<hr>

## 2021.04.01

**CSS vh**

vh는 view point 기준으로 퍼센트를 준다. 기존에 height 100%로 화면 전부를 채우려면, html, body 부터 시작해서 모든 부모의 높이를 100%로 설정하고 자신의 높이도 100%로 놓아야 화면을 전부 채웠지만, vh를 사용하면 부모의 height을 수정할 필요 없이 자신의 height을 100vh로 설정하면 된다.

```css
.backgroundDiv {
  height: 100vh;
}
```

참고로 vh는 viewpoint 기준 height 비율이다.

**모멘텀 TodoList, DoneList flex로 화면에 표시 및 높이에 vh 적용**

<hr>

## 2021.04.02

**JS IP, 서브넷 마스크 정규식으로 입력 형식 제한하기**

<hr>

## 2021.04.03

**<a href="./Book/CodeComplete/Chapter26.md">코드 컴플리트 26장 코드 튜닝 기법</a>**

여러 가지 코드 튜닝 기법을 배울 수 있었다. 하지만 가장 중요한 점은 코드 튜닝을 한 후 반드시 성능 테스트를 해야한다는 점이다. 또한 코드 튜닝으로 얻을 수 있는 성능과 좋은 코드의 가치를 비교한 후 튜닝 내용을 적용할 지 결정해야 한다.

<hr>

## 2021.04.04

**<a href="./Book/CodeComplete/Chapter27.md">코드 컴플리트 27장 프로그램의 크기가 구현에 미치는 영향</a>**

프로그램의 크기가 커질수록, 프로그램에서 구현활동이 차지하는 비율이 줄어든다. 대신 의사소통이나, 요구 분석, 설계에 드는 노력이 지수적으로 증가한다.

**JS mouseover-mouseenter, mouseleave-mouseout**

mouseover와 mouseenter의 차이점은 자식에게도 이벤트가 유지되는가이다. 중첩된 div 구조가 있을 때, 부모 div에 mouseover를 걸어놓고 마우스를 자식 div에 가져다대면, 부모 div는 여전히 mouseover 상태이다. 하지만 mouseenter의 경우 부모 div에 마우스가 있을 경우 mouseenter 상태이지만, 자식에게 마우스를 가져가면 mouseenter가 해제된다.

mouseleave와 mouseout도 마찬가지이다. 부모 div에 mouseleave를 걸어놓은 상태로 자식 div로 마우스를 가져갔을 때는 mouseleave 이벤트가 발생하지 않는다. 하지만 mouseout의 이벤트를 걸어놓으면, 자식 div로 마우스를 가져다 댔을 때, mouseout 이벤트가 발생한다.

**모멘텀 onMouseOver - onMouseLeave 사용해 이벤트 구성 및 리액트 아이콘 사용**

기존에 onMouseOver 이벤트와 onMouseOut 이벤트를 사용해 이벤트를 구성했더니, 오버 이벤트가 제대로 동작하지 않아서 leave 이벤트로 수정함.

무료로 제공되는 리엑트 아이콘을 사용해 메뉴 표시

<hr>

## 2021.04.05

**모멘텀 material ui 사용해 시간 변환 토글 생성**

material-ui 아이콘 패키지 설치

```bash
$ npm install --save '@material-ui/icons'
```

material-ui 아이콘 적용

```react
import Fab from '@material-ui/core/Fab';
import AddIcon from '@material-ui/icons/Add';
import Switch from '@material-ui/core/Switch';

<Fab size="small" color="secondary" aria-label="add">
	<AddIcon />
</Fab>
<Switch checked="{props.showFullHour}" onChange="{props.changeTimeFormat}" />
```

**모멘텀 5분마다 현재 위치 새로 받아오도록 변경**

<hr>

## 2021.04.06

**모멘텀 아이콘 정렬 및 시간 크기 수정**

<hr>

## 2021.04.07

**CSS word-break**

table td 태그 내부에 span 태그를 사용해 글을 넣을 때, 글이 길어지면 텍스트가 td를 빠져나가는 현상이 발생한다. 이를 막으려면 td 또는 table에 word-break 속성을 주면 된다.

```css
td {
  word-break: break-all;
}
```

내가 미리 정해둔 길이가 되면 텍스트를 하단으로 내린다. 기본 값은 단어별로 하단으로 내리는데, 단어 상관하지 않고, 그냥 내려버린다.

<hr>

## 2021.04.08

**모멘텀 시간 표현 아이콘 position absolute로 수정**

<hr>

## 2021.04.09

**모멘텀 툴팁 생성**

<hr>

## 2021.04.10

**<a href="./Book/CodeComplete/Chapter28.md">코드 컴플리트 28장 구현 관리</a>**

이번 장은 나보다는 관리자 또는 리더들에게 도움이 될만한 내용들이 주를 이뤘다.

**<a href="./css/CSS before와 after.md">CSS before와 after</a>**

어제 툴팁을 css의 after를 사용해 생성했는데, 정확한 기능을 몰라서 오늘 찾아봤다. 화면을 꾸미는데 유용하게 사용할 것이라 생각되고, 회사 프로젝트에서도 이미 before와 after를 사용하고 있는데 게을러서 그동안 찾아보지 않다가 오늘에서야 찾아봤다...

내용은 간단한데, before는 요소에 첫 번째 자식을 추가하는 것이고, after는 마지막 자식을 추가하는 것이다.

<hr>

## 2021.04.11

**<a href="./Book/CodeComplete/Chapter29.md">코드 컴플리트 29장 통합</a>**

이번 장에서는 여러가지 통합 방법에 대해 설명한다. 상향식, 하향식, 샌드위치, 위험지향 통합 등과 같은 방법에 대해 학부 과정에서 배운 내용들을 다시 상기할 수 있는 시간이었고, 어떤 통합을 선택하든지 그 과정에서 일일 빌드와 스모크 테스트가 프로젝트를 성공적으로 마치게 도와주는 방법이라는 것을 알게 되었다.

<hr>

## 2021.04.12

**<a href="./Book/CodeComplete/Chapter30.md">코드 컴플리트 30장 프로그래밍 도구</a>**

이번 장을 읽으면서 "VSCode 만세"라고 속으로 외쳤다. 프로그래밍 도구가 갖춰야할 모든 것을 갖추고 있다고 느껴진다.

### 모멘텀

**컴포넌트 파일로 분리**

기존 index.js에 있던 여러 컴포넌트들을 Momentum 컴포넌트를 제외하고 파일로 분리했다. 해당 컴포넌트 이름을 가진 js 파일을 만들고 파일에서 `export default 컴포넌트이름` 을 사용해 export 해주었고, index.html 파일에서는 `import 컴포넌트이름 from 경로` 로 import해 사용했다.

**기존 카카오 API 사용 개선**

불필요하게 index.html 파일에서 카카오 API를 가져오던 부분을 삭제하고, fetch만을 사용해 현재 지역을 가져오도록 수정

**기존 현재 지역 가져오는 부분 메서드로 만들어 사용**

기존에 카카오 API 사용해 현재 위치를 가져오는 부분을 메서드로 분리했다. 그리고 setInterval이 해당 시간 뒤에 처음 실행되는 것을 해결하기 위해, 먼저 한 번 실행하고, setInterval을 주었다.

**이슈 발생**

`window.navigator.getCurrentLocation`이 크롬과 파이어폭스에서 https가 아니면 지원하지 않는다고 한다. 현재 로컬 react 앱을 https로 변환하는 방법에 대해 연구해야겠다.

<hr>

## 2021.04.13

**모멘텀 https로 연결**

<hr>

## 2021.04.15

어제 회식으로 인해 공부를 못했다. 1일 1커밋이 벌써 끊길 거라고 생각 못했는데 오늘부터 다시 시작하자! 화이팅!

**모멘텀 현재 위치 날씨 표시**

카카오 API를 사용할 때 사용한 위도, 경도 데이터를 날씨 API에도 사용해서 현재 위치 기반 날씨를 받아온다. 근데 같은 위도 경도를 사용했는데 카카오 API에선 내 위치가 도봉구라고 뜨는데, 날씨 API에서는 의정부시라고 뜬다... 도봉구에 기상 관측소가 없나보다.

카카오 API 사용한 것과 똑같이 날씨 API를 사용했고, fetch를 사용해 GET 방식으로 요청하고 데이터를 받아왔다. 

현재 날시를 영문으로 Cloud 이렇게 표시하는데, 내일부터는 이것을 아이콘으로 표현하도록 바꿔야겠다.

<hr>

## 2021.04.16

**모멘텀 맑음, 흐림 아이콘 처리**

현재 날씨가 Cloud, Clear일 경우 아이콘 처리했는데, 다른 날시일 때는 어떻게 데이터를 주는지 모르겠어서 아직 처리를 못했다.

날씨 아이콘 처리가 끝나는대로, 온도를 표시하는 부분을 진행해야겠다.

<hr>

## 2021.04.17

**<a href="./Book/CodeComplete/Chapter31.md">코드 컴플리트 31장 레이아웃과 스타일</a>**

이번 장을 읽으면서 한 번 더 느꼈다. VSCode 고맙다!



### 모멘텀

* Rain 아이콘 추가
* 현재 온도 올림해서 화면에 표시

<hr>

## 2021.04.18

**<a href="./Book/CodeComplete/Chapter32.md">코드 컴플리트 32장 스스로를 설명하는 코드</a>**

단순 코드 반복이 아닌, 효과적인 주석을 작성하기 위해 노력하자! 그리고, 애매한 코드에 주석을 장황하게 작성하지 말고, 코드를 다시 작성하자!

<hr>

## 2021.04.19

**모멘텀 API 키 외부 파일로 분리**

외부 파일로 분리하고, gitignore에 해당 파일을 추가해 깃허브에 api 키가 노출되지 않도록 함

<hr>

## 2021.04.20

### 모멘텀

* 날씨 아이콘 크기 조정
* 폰트 크기 rem으로 수정

<hr>

## 2021.04.21

**JS event.stopPropagation**

리액트에서 stopPropagation을 사용할 때는, 해당 이벤트가 발생한 곳에서만 사용해야 한다.

나는 부모 컴포넌트에서 메서드를 자식 컴포넌트로 전달해줄 때, 부모 컴포넌트에 `event.stopPropagation()`을 사용했는데 오류가 났다. 이벤트가 발생하는 컴포넌트에서 stopPropagation을 사용하면 정상적으로 동작한다.

<hr>

## 2021.04.22

**모멘텀 기능 마무리**

* 모멘텀의 전체적인 기능을 마무리함
* 기존 모멘텀에서 1개의 todo를 기록할 수 있었던 것을 여러개를 기록하고, 추가로 done 리스트를 두어서 드래그 앤 드롭으로 이동할 수 있도록 하였음
* 24시간 표기법과 12시간 표기법 중 토글 버튼을 두어 사용자가 선택할 수 있도록 함
* 현재 위치와 날씨 표시

전체적으로 위의 기능들을 구현하였고, 아직 아쉬운 부분도 많다. 배경 클릭 시 기존 설명 창이나 이런 것들이 다 사라지도록 하거나, 퍼센트로 시간을 표시하는 기능을 넣고 싶은데 퍼센트는 충분히 가능하다고 생각하는데 배경 클릭은 조금 시간이 걸릴 것 같다. 오늘까지 도전해봤는데, Time 컴포넌트 쪽에 있는 state를 위로 끌어올려야 돼서, 나름 큰 공사가 될 것 같다.



모멘텀을 만들면서, CSS적인 부분에 대해 조금 더 알게 되었다. 특히 툴팁을 만들 때, width와 height을 0으로 주고, border로만 세모를 만드는 것은 충격이었고, before와 after에 대해서도 지금 당장 사용할 수 있는 유용한 부분이었다. 그리고 display flex가 이렇게 강력한지 몰랐다. 사실 flex가 뭔지도 몰랐는데, 너무 좋은 기능이라고 생각이 든다. layout 부분도 조금 더 공부해보고 싶다.

아쉬운 점은 혼자 진행하고, 독학이기 때문에 내 코딩 스타일이 다른 사람이 봤을 때도 보기 쉬운가에 대한 의문은 든다. 내가 봐도 보기 어려운데... 초반에 작성한 부분을 나중에 고치려고 하니 많은 문제가 발생되었다. 이번엔 그래도 설계를 거쳐서 작성한 건데도 이 정도다. 이름 짓는 것과, 컴포넌트를 분리하는 것에 노하우가 아직 많이 부족하다는 생각이 들었다. 

그래도 리액트를 사용해 이 정도 웹앱을 만들었다는 점은 만족한다. 2월 처음 리액트 독학을 시작했을 때는 JSX 왜이리 어렵고, 컴포넌트랑 state, props를 왜 이렇게 사용하지? 언제는 this 바인딩을 생성자에서 해주고, 언제는 안해도 되는거지? 이런 것에 대한 궁금증이 많았는데, 지금 내가 쓴 부분에 대해서는 자신감이 생겼고 대답도 할 수 있을 정도가 되었다. 



벨로퍼트님 투두리스트 만드는 것을 이번에 글로 읽으면서 진행해보려고 한다. 사실 첫 페이지 읽어봤는데 마지막에 도전할 수 있도록 과제를 주시는 부분이 너무 맘에 들었다. 이번 주 안으로 벨로퍼트님의 투두리스트까지 마무리하고, 다음주는 스테이트 관리 라이브러리와 리액트 라우트에 대해 공부를 시작해야겠다는 마음이 들었다. 지금 내가 만든 모멘텀은 한 페이지에서만 동작하기 때문에 라우터도 필요 없지만 추후에 진행할 프로젝트에서는 그래도 여기 저기 다녀야하지 않을까? 하기 때문에 미래를 위한 라우터와, 이번에 스테이트 끌어올리기를 리액트 스테이트 관리 라이브러리가 도움을 줄 수 있지 않을까? 라는 막연한 생각 때문에 공부를 하고 싶어졌다.

<hr>

## 2021.04.23

**리덕스**

이번에 알게 된 부분이 기존 리액트 라이브러리를 사용할 때, state가 변경되면, 변경된 사실을 주변으로 퍼뜨리게 되는데, 리액트에서 권장하는 state 전파는 부모를 통해 변경 사실을 퍼뜨리는 것이고, 직접적인 전달은 권장하지 않는다.  근데 이렇게 사용하게 되면, 너무 먼 경로를 사용하지도 않는 state를 전파하는데 사용하게 되서 기능을 추가하거나 수정하기가 조금 까다로워진다.

리덕스를 사용하면 state를 좀 더 쉽게 관리할 수 있다. state를 리덕스에 등록시키고, 해당 state를 사용하는 다른 컴포넌트는 구독을 누르면 state의 변경 사항을 리덕스가 알려준다.

어제까지 진행했던 모멘텀 프로젝트에 리덕스를 도입해서 배경화면 클릭 기능을 추가해야겠다는 생각이 들었고, 회사에서 진행하는 프로젝트(비록 AngularJS를 사용하지만)에도 리엑트 + 리덕스를 도입하면 화면의 UX를 크게 개선할 수 있을 것 같다는 생각이 들었다. 이는 물론 성능 측정을 해봐야 아는 거긴 한데, 현재 우리의 화면이 너무 느린 느낌을 나는 받는다. 내가 만든 경고등이나, 서버 연결 상태 등과 같은 것들도, 서버로부터 3초마다 값을 받아오는 부분을 리덕스에 등록하고, 이를 구독해서 서버의 연결 상태가 끊어지거나, 경고등이 새로 들어오게 되면 화면에 바로 이를 반영할 수 있을 것 같다. 기존에 사용하고 있던 `setInterval`을 여러번 사용하지 않고, 서버로부터 지속적으로 값을 받는 부분에만 사용하면 되고, 현재 불필요한 렌더링이 나는 조금 느껴지긴 한다. 경고등은 하루에 최대 한 번만 바뀔 수 있는 기능인데도, 5초마다 값을 읽어서 화면을 다시 렌더링하기 때문에 미세하게 깜빡이는 것이 보여진다. 물론 AngularJS에도 이를 개선할 수 있는 방법들이 있지만, 리액트를 사용하면 내가 만든 부분 뿐아니라 다른 분들이 진행한 곳에서도 더 많은 개선을 이룰 수 있을 것 같다.

AngularJs가 확실히 편하다. scope을 사용한 양방향 바인딩도 그렇고, ng-repeat나 ng-if 등을 사용해 화면에서 JS에서 사용한 값들을 다룰 수 있는 점은 매우 매력적이다. 그리고 실시간으로 바뀌는 차트를 보여줄 때, 리액트의 virtual DOM이 AngularJS의 DOM 렌더링보다 더 좋은 성능을 보여줄 것이라는 확신도 들지 않는다. 하지만 리액트를 사용함으로써 조금더 모듈화된 컴포넌트를 사용할 수 있고(물론 기존의 AngularJS도 directive와 service를 제공하지만 개인적으로 재사용성은 리액트의 컴포넌트가 높다고 느껴짐) 불필요한 렌더링을 크게 줄일 수 있다는 확신은 든다.

리덕스를 새로 배우고 사용할 생각에 지금 두근거린다. 이런 흥미를 느낄 수 있음에 너무 감사하다. 끊임없는 동기부여와 격려를 주시는 케빈, 제임스. 그리고 닮고 싶은 사람인 데니스와 모르는 것이 없는 루카스. 그리고 내 도움 요청에 자기 일처럼 열정적으로 도움울 주시는 필립과 커리어 전반적인 조언과, 무미 건조한 점심 시간을 정말 즐거운 시간으로 변화시켜 주시는 리바이. 그리고 회사 생활에 필요한 일들에 실질적으로 도움을 주시는 콜린과 항상 사무실에 에너지를 주는 줄리에게 너무 감사하다. 올해 2월부터 지금까지 정말 행복한 시간들의 연속인 것 같다. 이번 주말은 코드 컴플리트를 다 읽고, 리덕스를 기존 모멘텀에 적용하는게 목표다. 그리고 다음 한 주는 그동안 내가 일단 지금 증상만 고쳐놓은 것들을 다시 손볼 계획이다. 내가 머물던 장소는 내가 머물기 전보다 더 깨끗하게 해놓아야 한다는 원칙을 실행하는 한 주를 보내는 것이 다음 주의 목표이다. 리액트 + 리덕스를 내 기술로 만들어서 좋은 퍼포먼스를 발휘하는 개발자로 진화하자!

<hr>

## 2021.04.24

**<a href="./Book/CodeComplete/Chapter33.md">코드 컴플리트 33장 개발자의 성격</a>**

지적인 정직함이 있는 개발자가 되자!!



**모멘텀에 리덕스 추가 및 기본 테스트**

<hr>

## 2021.04.25

**<a href="./Book/CodeComplete/Chapter34.md">코드 컴플리트 34장 소프트웨어 장인정신에 대한 주제</a>**

이 책 전반적인 내용에 대한 리뷰같다는 느낌을 많이 받았다. 이전에 책을 읽으면서 배웠던 내용을 다시 한번 상기시키는 기회가 되었다.



**<a href="./Book/CodeComplete/Chapter35.md">코드 컴플리트 35장 더 많은 정보를 얻으려면</a>**

더 많은 책들과 정기 간행물을 추천해준다. 

드디어 다 읽었다. 정말 기쁘고 그동안 고생 많았다!!! 쉬지 않고 지금 잡힌 루틴대로 다음 도서는 실용주의 프로그래머가 될 예정이다. 실용주의 프로그래머도 잘 읽고 좋은 개발자가 되보자!!

<hr>

## 2021.04.26

**모멘텀에 리덕스 사용해 배경 클릭시 메뉴 사라지도록 구현**

리덕스를 사용해서 배경 클릭시 기존에 메뉴가 모두 보이지 않도록 하는 기능을 구현했다. 최종적으로 모든 기능을 완성했고, 다른 작업들과 공부를 하면서 보완점을 수정해 나가는 식으로 진행하겠다.

<hr>

## 2021.04.27

**모멘텀 코드정리**



**벨로퍼트 투두 리스트 초기 템플릿 생성**

함수형 컴포넌트를 만들 때 children을 조금 더 쉽게 사용하는 방법은 아래 처럼 비구조적 할당을 하면 된다.

```react
const TodoTemplate = ({form, children}) => {
    ...
    return (
        <div>
        	{form}
            {children}
        </div>
    );
}
```

form과 children에는 JSX 문법을 사용할 수 있다.

<hr>

## 2021.04.28

**벨로퍼트 투두리스트 템플릿 완성**

<hr>

## 2021.04.29

**벨로퍼트 투두리스트 상태관리 완성**

비구조화 할당의 편리함을 깨달았다. 객체를 매개변수로 사용할 때 비구조화 할당을 하면 '.'을 사용하지 않아도 되고, 그래서 보기도 조금 더 쉬운 것 같다.

`[...배열이름]`을 사용해 배열을 복사할 수 있다는 것을 배웠고, 리액트에서 state에 배열 또는 객체를 사용할 때 push를 사용하지 않아야 하는 이유를 알게 되었다. 주소 값으로 비교를해야 더 빠르게 동작하기 때문에, 렌더링을 더 빠르게 하기 위해 배열 또는 객체의 주소를 바꾸는 것이 좋다.

<hr>

## 2021.04.30

**벨로퍼트 투두리스트 렌더링 최적화**

`shouldComponentUpdate(nextProps, nextState)`를 사용해 렌더링할 조건을 정할 수 있다.



**토스 컨퍼런스 프론트엔드 클린코드**

클린코드 !== 짧은코드

<hr>

## 2021.05.01

**실용주의 프로그래머 서론**

이 책의 내용이 너무 궁금해졌다. 서론에서 느껴지는 분위기는 자신이 모든 것을 해결해 줄 수 있는 능력은 없으나 많은 문제에 구체적인 방법을 제시할 수 있다고 말하는 것 처럼 느껴졌다.

나도 내가 사용하는 기술에 애정을 가지고, 생각하며 일하고 싶다. 사실 AngularJS를 이미 사장된 기술이라고 생각하고, 다른 프레임워크를 사용하고 싶다는 생각만 가지고 있었는데 AngularJS를 사용해서 더 근본적인 Javascript 지식을 함양하고, 어떤 프레임워크가 등장해도 기본이 잡혀있는 개발자가 되어야겠다는 생각이 들었다.

<hr>

## 2021.05.02

**<a href="./Book/ThePragmaticProgrammer.Chapter1.md">실용주의 프로그래머 1장 실용주의 철학</a>**

코드 컴플리트에서 읽었던 내용들이 많이 생각났다. 거의 결을 같이 하는 것 같다. 지적 솔직함을 중요시하자!

## 2021.05.03

**리액트 - 익스프레스 연동**

일단 보고 따라하면서 연동은 했는데, 프록시에 대해 조금 더 알아보고, 코드 내용도 하나씩 분석해서 블로그에 글을 올려야겠다는 생각이 들었다.

<hr>

## 2021.05.04

**`i++` vs `++i`**

결과부터 말하면 `++i`가 더 좋다(특별히 `i++`을 써야하는 경우가 아니라면). `i++`을 사용하면 temp 변수를 임시 할당하기 때문에, 메모리 관리가 중요한 프로젝트에서 ++를 앞에다 사용하는 것을 권장한다.

<hr>

## 2021.05.05

**<a href="./Book/ThePragmaticProgrammer.Chapter2.md">실용주의 프로그래머 2장 실용주의 접근법</a>**

직교성과 가역성을 기억하자!



**위키 초기설정 및 express - mongodb 연동**

<hr>

## 2021.05.06

회식한 후 집에 들어오니 11시 10분입니다... 이번 주말에 오늘 몫까지 더 열심히 하자!!! 제발!!!

<hr>

## 2021.05.07

**위키 express 구동 코드 해설**

<a href="./FriendWiki/Documents/Express시작하기.md">여기</a>를 클릭하면 해당 문서를 볼 수 있다.

생활코딩으로 express를 배웠던 기억이 조금씩 떠오른다.

<hr>

## 2021.05.08

**<a href="./Book/ThePragmaticProgrammer/Chapter3.md">실용주의 프로그래머 3장 기본적인 도구</a>**

VSCode에서 벗어나 이를 사용하지 않고 문서를 다룰 수 있는 사람이 되는 것이 첫 번째, 그리고 VSCode의 마스터가 되는 것이 두 번째.

<hr>

## 2021.05.09

**<a href="./Book/ThePragmaticProgrammer/Chapter4.md">실용주의 프로그래머 4장 실용주의 편집증</a>**

예외 처리 기법과 자원 할당 해제 원칙에 대해 다뤘다.

<hr>

## 2021.05.10

**JS Closure**

JS에서 클로져를 사용해 내부 값에 접근하지 못하도록 할 수 있다고 하는데 당연한거 아닌가(?)라는 위험한 생각이 들었다. 조금더 자세히 알아보고 정확한 개념을 잡아야겠다.

<hr>

## 2021.05.11

**git init으로 프로젝트 시작해서 github에 올리기**

ssh를 사용하는 방법과, 처음 프로젝트를 github에 올리는 것을 했는데 앞으로는 git clone 대신 이 방법을 주로 이용하게 될 것 같다.

<hr>

## 2021.05.12

**슬랙으로 깃허브 알림받기**

<hr>

## 2021.05.13

**MongoDB 모델 사용**

**postman 사용해서 서버로 post 메시지 전송**

<hr>

## 2021.05.14

**bcrypt 사용해 비밀번호 암호화**

**AngularJS scope 간의 통신**

<hr>

## 2021.05.15

**<a href="./Book/ThePragmaticProgrammer/Chapter5.md">실용주의 프로그래머 5장 구부러지거나 부러지거나</a>**

결합도를 줄여야 하는 이유와 결합도를 줄이는 방법에 대해 설명한다.

**cookie-parser, jsonwebtoken 사용하기**

<hr>

## 2021.05.16

**<a href="./Book/ThePragmaticProgrammer/Chapter6.md">실용주의 프로그래머 6장 코딩하는 동안 해야 할 일들</a>**

리팩터링과 테스트, 의도적인 프로그래밍에 대해 설명했고, 나에게 큰 울림을 주는 내용들이었다.

**Express**

* auth 기능 추가
* 로그아웃 기능 추가

<hr>

## 2021.05.17

**git init으로 만든 레포지토리 원격 github에 등록하기 블로그에 정리**



**test 애플리케이션 서버 클라이언트 구분 및 리액트 설치**



**npx**

npx는 npm으로 설치해서 실행하지 않고, npm registry에 들어있는 내용을 다운로드 받지 않고, 해당 내용을 사용만 할 수 있게 해주는데, 항상 최신 버전을 사용할 수 있고, 디스크 공간을 절약할 수 있게 해준다.



## 2021.05.18

**react-router-dom**

리액트에서 라우터 기능을 해주는 react router dom을 사용해 봤다. 일단 사용법은 너무 간단했다.

```react
import {
    BrowserRouter as Router,
    Switch,
    Route
}

function App() {
    return (
        <Router>
            <div>
            	<Switch>
                    <Route exact path='/' component={Home} />
                    <Route exact path='/login' component={Login} />
                </Switch>
            </div>
        </Router>
    );
}
```

이렇게 사용하고, path에 지정해 둔 경로로 갈 경우 옆에 놓은 component에 넣은 컴포넌트가 렌더링 된다. 뭔가 스위치문을 사용해도 이렇게 할 수 있을 것 같은데 경로 지정해서 나오도록 하는 것은 좀 더 알아봐야해서, 코드를 읽어봐야 정확히 알 수 있을 것 같다.

<hr>

## 2021.05.19

**express 에서 cors 사용하기**

```javascript
const cors = require('cors');
app.use(cors());
```

사용법은 굉장히 간편한데, 이게 모든 요청에 대해 다 응답을 보내는 것 같아서 보안적으로는 취약할 것 같다는 생각이 든다. 그리고 react 에서 `http-proxy-middleware`를 사용해서 요청 URL을 바꿔보기도 했는데, CORS 문제가 해결되지 않아서 원인 분석이 필요하다.

결국 프론트엔드에서 CORS 문제를 해결하지 못해서 백엔드에서 cors를 사용하게 되었고, 문제는 해결했는데 보안적 문제는 없는지 조사해봐야 한다.

<hr>

## 2021.05.20

**concurrently 사용해서 backend, frontend 한 번에 실행하기**

기존에 백엔드 부분인 express를 실행하기 위해서는 해당 디렉터리에서 `npm run backend` 를 입력해서 실행시키고, 클라이언트 부분인 react를 실행하기 위해서는 해당 디렉터리로 이동한 후에 `npm run start` 를 입력해서 실행시켰다. 

이를 한 번의 명령어 입력으로 실행 시키는 패키지가 "concurrently" 이다.

일단 npm을 사용해서 설치를 한다.

```bash
npm install concurrently --save
```

 설치가 끝나면 "package.json" 파일을 열고 script 부분에 아래 명령어를 추가해주면 된다.

```json
{
    ...
    "script": {
        "backend": "nodemon server/index.js",
        "dev": "concurrently \"npm run backend\" \"npm run start --prefix client\""
    }
}
```

`dev` 부분을 추가한 것인데, 이제 이를 실행하려면 `npm run dev` 라고 쉘에 입력하면 된다. 

`dev` 부분을 조금 해석하자면, concurrently를 사용해 동시에 실행하겠다는 것을 알려주고, 첫 번째 인자로 `npm run backend` 를 넘기고, 두 번째 인자로 `npm run start --prefix client` 를넘겨서, 백엔드와 프론트엔드를 동시에 실행한다. "prefix" 를 사용해 해당 디렉터리의 스크립트를 실행한다.

<hr>

## 2021.05.21

**test에 redux 설치**

리덕스를 설치하면서 `redux-promise` 와 `redux-thunk` 를 같이 설치 했는데, 오늘 들은 설명으로는 이 둘이 리덕스로 promise와 function을 사용하기 위한 미들웨어라는 설명을 들었다.

아 그리고 미들웨어에 대해 사실 그동안은 제대로 몰랐는데, 이번에 공부하면서 미들웨어라는 개념을 나는 다음 단계로 넘어가기 전에 실행되는 음.. 프록시 역할? 과 비슷하다고 느껴졌다. 그리고 실제로 그런 개념으로 사용하고 있는데, 이게 잘하는 것인지, 그리고 내가 잘 이해한 것인지 모르겠다.

<hr>

## 2021.05.22

**<a href="./Book/ThePragmaticProgrammer/Chapter7.md">실용주의 프로그래머 7장 프로젝트 전에</a>**

프로젝트 전에 수행되어야 할 요구사항 수립과 프로젝트 방향 설정에 대한 내용을 다룬다. 요구사항을 수집하지 말고 채굴하라는 말이 많은 깨달음을 줬다.



**JS event.target과 event.currentTarget**

`event.target` : 이벤트가 발생한 대상을 나타냄

`event.currentTarget` : 이벤트를 발생시킨 대상을 나타냄



```react
buttonClick = (event) => {
    console.log(event.target);
    console.log(event.currentTarget);
}

<button onClick={buttonClick}>
	<span>BUTTON</span>
</button>
```



위처럼 설정하고 `<span>` 부분을 클릭하면

* `event.target` : `<span>BUTTON</span>`
* `event.currentTarget` : `<button><span>BUTTON</span></button>`

결과는 위와 같다.

<hr>

## 2021.05.23

**<a href="./Book/ThePragmaticProgrammer">실용주의 프로그래머 8장 실용주의 프로젝트</a>**

자동화 할 수 있는 모든 것을 자동화하고, 내가 한 작업을 자랑하고, 책임지자.

**로그인 기능**

백엔드에서 생성한 토큰을 프론트엔드로 전달하고, 프론트엔드에서는 이 토큰을 로컬스토리지에 저장했는데, 백엔드에서 프론트엔드로 토큰을 전달하는 것이 맞는 방법인지 모르겠다. 만약 이 토큰이 탈취되면 로그인한 사람처럼 행동할 수 있을 것 같은데, 보안적으로 취약해보이는데 좀 더 알아봐야겠다.

일단 로그인 로그아웃 기능은 만들었고, 다음으로 auth 기능을 사용해 권한이 없으면 해당 페이지로 이동할 수 없는 기능을 추가해야 한다.

<hr>

## 2021.05.24

**로그인 회원가입 페이지 리액트 부분 추가**

**<span style="color:red;">Set cookie가 동작하지 않는 이슈 발생</span>**

일단 Set-Cookie 대신 localstorage에 액세스 토큰을 저장하는 방식으로 변경하였는데, 왜 set-cookie 가 작동하지 않는지에 대해서는 공부해야 할 필요가 있음.

<hr>

## 2021.05.25

**react HOC**

HOC은 Higher Order Component의 약자로, `HOCComponent(WarppedComponent)` 형태로 사용한다. 사용 목적은, 조건에 따라 다른 컴포넌트를 리턴하기 위해서 사용하고, 나는 사용자 권한 또는 로그인 여부에 따라 특정 컴포넌트를 보여줄지, 보여주지 않을지 결정하는 데 사용하려한다.

<hr>

## 2021.05.26

**react hook**

공식 문서를 모두 읽었는데, 굉장히 편리해 보이는게 많았다. 사실 처음에 훅 부분을 봤을 때, 리액트에 대해서도 제대로 몰랐어서 어려우니 다음에 봐야겠다는 생각이 들었는데, 지금은 리액트에 어느정도 익숙해져서 그런지 내용이 볼만했다. 어제 조금 알아봤던 HOC를 훅으로 대체할 수 있다는 것과, 기존에 상태주기 메서드를 사용하면서 발생할 수 있는 문제점들을 훅을 통해 해결했다는 것이 인상깊었다.



**로그인 회원가입 인증 템플릿 완성**

MERN 스택으로 로그인, 회원가입, 인증 부분을 처리하는 것을 완료했다. 간단한 기능인데도 알아야 할 것이 많았고, 아직도 공부할 것이 매우 많구나 라는 것을 느꼈다.

<hr>

## 2021.05.27

**위키**

- express - mongodb 연동
- mongodb 모델 생성
- <a href="https://github.com/Chamy619/Friend_Wiki/blob/develop/docs/register.md">회원가입 백엔드 기능 완성</a>

<hr>

## 2021.05.28

**위키**

* <a href="https://github.com/Chamy619/Friend_Wiki/blob/develop/docs/login.md">서버 로그인 api 구성</a>



아! 그리고 좋은 소식 하나 전하고 싶다. 하나님의 도움으로 우아한 테크 러닝을 통해 리액트와 타입 스크립트를 배울 수 있게 되었다. 6월 1일 부터 시작인데 이런 기회를 준 우아한 형제들에게 너무 감사하다. 우리 회사에서도 리액트로 새로운 프로젝트에 도입하려고 하고 있는 상황에서 이런 기회가 생긴 것이 정말 하나님의 계획 안에 내가 있다는 것이 느껴진다. 정말 너무너무 감사하고, 행복했다.

사실 우아한 형제들에서 나에게 돈을 준다거나, 채용 기회를 주는 것은 아니지만, 우아한 형제들의 배움이라는 기회를 준 것에 이렇게 감사하다는 생각이 든 이유에 대해 생각해봤는데, 기업의 브랜드가치가 아닐까? 에 생각이 다다랐다. 우리나라의 서비스 개발을 이끌어 나가는 기업에서 배울 수 있다는 것  만으로도 엄청난 성취감과 소속감을 느낄 수 있었다.

이번에 배우는 내용을 바탕으로 새로운 프로젝트를 성공적으로 마쳐서, 우리 회사의 브랜드 가치를 높이는데 기여하고 싶다. 그러기 위해서 갈 길이 멀지만 지금처럼 꾸준하게 한 발씩 나아가면 언젠가는 가능하지 않을까?



## 2021.05.29

**<a href="./Book/읽기 좋은 코드가 좋은 코드다/Chapter1.md">읽기 좋은 코드가 좋은 코드다 1장. 코드는 이해하기 쉬워야 한다.</a>**

가독성이 좋은 코드가 소프트웨어의 효율성과 디자인을 망치는 데에 주는 영향이 거의 없다. 따라서 가독성이 좋은 코드를 작성해야 한다.



**위키**

* <a href="https://github.com/Chamy619/Friend_Wiki/blob/develop/docs/logout.md">서버 로그아웃 api 구성</a>

<hr>

## 2021.05.30

**<a href="./Book/읽기 좋은 코드가 좋은 코드다/Chapter2.md">읽기 좋은 코드가 좋은 코드다 2장. 이름에 정보 담기</a>**

이름에 길이에 상관 없이 의미 있는 이름을 짓자.

**위키 회원가입 이슈**

~~회원가입 프론트 작업 중 redux를 사용했는데 Provider를 사용하라는 이슈가 발생~~

회원가입 페이지 완성

로그인 페이지 완성



**리덕스 사용기**

리덕스를 사용하는데 index.tsx 에 루트 리덕스 스토어를 표시 안해서 `<Provider>` 를 사용하라는 에러가 났다. 리덕스를 처음 사용할 때 루트 리덕스를 꼭 리액트의 루트 파일에 추가하는 습관을 들여야겠다.



**타입스크립트 처음**

처음을 타입스크립트를 사용해봤다. 아직은 조금 어렵다고 느껴지는 부분이 많았는데, 점점 더 편리함이 많이 느껴지길 바란다.

일단 처음 사용하면서 좋았던 점은, 바로바로 타입 체크가 가능해서, 실행해보기 전에 에러를 찾는 빈도가 늘어났다. 그리고 상세한 코멘트까지 있어서 정말 편리했다. 그리고 오타도 쉽게 발견할 수 있다. 타입스크립트를 사용하지 않으면, 정말 오래 헤맸을 법한 오타들을 발견하면서 '아! 정말 좋다!' 라는 생각이 들었다.

불편했던 점은 아직 내가 부족해서인 것이 대부분인데, 그 중 하나가 어느 부분에서는 `any` 타입을 명시하지 않아도 동작하는데, 어디서는 또 `any` 를 명시하지 않으면 에러가 발생했다. 물론 `any` 타임을 최대한 사용하지 않는 것이 좋긴 한데, 내가 아직 해당 변수 또는 객체의 타입을 모를 경우 어쩔 수 없지 않나... 그리고 대표적으로 `event` 를 다룰 때는 꼭 `any` 를 명시해줘야 하는 것 처럼 오늘 느껴졌는데, 왜 그런 것인지 궁금하다.

<hr>

## 2021.05.31

**위키 로그아웃 및 페이지 이동 권한 설정**

HOC를 사용해서 페이지 이동 권한을 설정했는데, 이 부분은 따로 공부해야 할 것 같다. 그리고 어제 `event` 를 다룰 때 `any` 를 명시해야 된다고 썼는데, `any` 대신 `React.ChangeEvent<HTMLInputElement>` 를 줘도 된다. 물론 input 태그의 onChange 이벤트가 아닐 경우 ChangeEvent와 HTMLInputElement 대신 다른 것이 들어가야 한다.

<hr>

## 2021.06.01

**<a href="./WoowaTechLearning/우아한 테크러닝 1회차.md">우아한 테크러닝 1회차</a>**

너무 재밌었다. 기술 이사님의 말투와, 질문을 끝까지 듣고 대답하시는 것을 보면서 개발자로서의 기술적인 능력도 중요하지만, 경청하고 말하는 자세도 중요한 것 같다는 생각이 들었다. 너무 멋있어 보였고, 이러한 자리를 마련해 주신 것에 너무 감사했다.

이런 테크 러닝을 열게 된 이유가 굉장히 인상깊었다. 우아한 형제들을 홍보해서 좋은 개발자가 지원하고 싶다라는 마음을 가지게 하기 위함이라고 하는데, 사실 누구나 가고 싶은 기업 중 하나가 우아한 형제들이 아닌가? 그럼에도 더 좋은 사람을 뽑기 위해 이런 교육에 힘쓰는 것을 보면서, 내부 분위기가 너무 궁금해졌다. 나도 그런 문화를 가진 기업에서 일을 해볼 수 있을까? 아니면 내가 기업의 문화를 바꾸는데 앞장서는 사람이 될 수 있을까?

배달의 민족도 처음부터 좋은 개발 문화가 정착된 채로 시작한 것이 아니라 협력해서 만들어 간 것일텐데, 나라고 못할 이유는 없지 않나? 라는 생각이 들었다. 아직 힘이 굉장히 부족한 신입이지만 실력을 쌓아서, 어느정도 인정받는 상황이 되면, 좋은 개발 문화. 음.. 누구나 자신의 의견을 자유롭게 낼 수 있는 문화를 만드는데 도움이 되는 사람이 되고 싶다.



일단 너무 재밌었다. 그리고 다음 교육이 기대가 된다. 다른 사람들은 프로젝트를 어떻게 구상해올지 너무 궁금하고, 나도 빨리 만들어서 깃허브에 올리고 싶다. 4주차가 지났을 때, 내가 리액트를 보는 관점이 지금과 어떻게 달라졌을지 너무나도 궁금하고, 타입스크립트에 대한 내 생각과 실력이 궁금하다. 리액트라는 라이브러리에 대한 기술적인 이해와 사용 능력이 지금 많이 부족하다고 느끼는 상태이고, 타입스크립트는 이번 주말에 처음보았는데 잘 할 수 있을까? 라는 생각도 들고, 정말 잠 줄여가면서 도전해보고 싶다는 생각도 든다. 너무 흥분되고, 이렇게 재밌게 느껴지는게 왜 대학교 1, 2 학년 때는 느끼지 못했을까? 라는 아쉬움도 든다. 그 때 이런 감정을 느꼈다면 지금쯤 더 좋은? 아니면 능력있는 개발자가 되었을 것 같은데. 그래도 지금이라도 흥미를 느끼는 것에 감사하는 마음으로 한 발 더 나아가야겠다.

<hr>

## 2021.06.02

**<a href="https://github.com/Chamy619/notion_bot/">우아한 테크코스 레포 세팅</a>**

프론트는 typescript와 react를 이용해 구성했고, `create-react-app` 을 사용해서, 조금 편하게 갔다.

```bash
npx create-react-app . --template typescript
```



백엔드는 nodejs, express에 typescript를 적용하는 것에는 성공했는데, 타입스크립트를 이번에  처음 사용해 보는데, 백엔드까지 사용하게되면 타입스크립트 공부에 너무 많은 시간을 사용하게 될까봐, 여기서는 타입스크립트를 사용하지 않았다.



문제는 마크다운 파서를 적용하는게 문제였는데, 일단 `markdown-to-jsx` 를 사용하기로 결정했다. compiler를 사용해서, 변환되기 전의 상태를 확인할 수 있다는 점과, typescript를 지원하는 점에서 높은 점수를 줬다. 사실 타입스크립트를 지원하는 파서는 여러 개가 있었는데, 3개 정도 사용해본 결과, `markdown-to-jsx` 가 내가 사용하기에 가장 편했다.

일단 파서를 적용해서 뿌린는 것을 해봤는데, 결과가 인풋창에 바로 반영되게 하는 것을 아직 생각 못했다. 이 부분 어떻게 구현할지에 대해 조금 더 생각해 보아야 할 것 같다.

---

## 2021.06.03

**<a href="./WoowaTechLearning/우아한 테크러닝 2회차.md">우아한 테크러닝 2회차</a>**

의사소통의 중요성을 깨달았다. 서로 `당연히 이거겠지` 라는 생각이 문제를 유발할 수 있다는 점을 깨달았다.



프로젝트의 규모가 커질수록 디펜던시와 같은 복잡성이 증가한다. 처음 계획할 때, 너무 규모를 크게 잡고 설계할 경우 오버 엔지니어링이 발생하기 때문에, 선을 잡는 것이 중요하다. Create React App은 모든 상황을 담으려고 했기 때문에 사용하면 오버 엔지니어링이 발생할 수 있다.  --> Webpack을 공부해야할 필요성을 여기서 느꼈다.



외부 라이브러리를 선택할 때

1. 해당 라이브러리가 우리가 사용하는 언어 또는 프레임워크를 지원 하는지
2. 커스터마이징이 어디까지 가능한지
3. 자기 자신을 어떻게 설명하는지
4. 개발 원칙이 어떤지

에 대해 고민하고 선택하자. 그리고 모든 선택에는 이유가 있을 것이고, 이를 명확하게 알고 있는 것이 중요하다.



깃허브 repository를 만들 때, 프론트엔드와 백엔드를 한 곳에 놓는 것보다 분리해서 놓는 것이 더 좋을 수 있다. -> 프론트엔드와 백엔드의 배포 사이클이 다를 경우의 수가 더 높다.

---

## 2021.06.04

**webpack 사용해 리액트 시작하기**

---

## 2021.06.05

**미니 노션**

구글 로그인 기능 구현

---

## 2021.06.06

**미니 노션**

구글 로그아웃 기능 추가



**에디터 프로토타입 제작**

두 개의 라이브러리를 사용해서 프로토타입을 제작해 봤다. 프로토타입 제작은 `codesandbox` 를 사용했다.

* draft-js

프로토타입은 <a href="[draft-js/prototype - CodeSandbox](https://codesandbox.io/s/fyv91)">여기</a> 에서 확인할 수 있다.

페이스북에서 관리하고 있고, 리액트 타입스크립트와 잘 맞는 느낌이 들었다. 문서도 잘 정리되어 있어서 문서를 통해 대부분의 내용을 배울 수 있다. 많은 기능을 커스터마이징 할 수 있고, 다양한 플러그인들도 존재했다.

하지만 직접 이벤트를 추가하는 것이 나한테는 조금 어렵게 느껴졌다. 



* slate-js

이 역시 리액트 타입스크립트를 제공하고 있다. 타입스크립트를 사용할 때, 에러가 조금 나타나는 경우가 있지만, 이에 대한 설명도 문서에 잘 드러나 있다. 이 역시 많은 기능을 커스터마이징 할 수 있는데, 특히 키다운 이벤트를 사용해서 기능을 생성하는 것이 편리했다. 기능 추가하는 것도 어렵지 않아서, 문서에 나와있는 튜토리얼만으로도 충분히 배울 수 있었다. 

프로토타입은 <a href="[slate-js/prototype - CodeSandbox](https://codesandbox.io/s/8tbiz)">여기</a> 에서 확인할 수 있다.

---

## 2021.06.07

### 미니 노션

* 네이버 로그인 기능 추가
* express api들 router로 분리

자세한 정보는 <a href="https://chamy619.tistory.com/129">여기</a> 에서 확인할 수 있다.

---

## 2021.06.08

**우아한 테크코스 3회차**

오늘 민태님께 들었던 내용 중 가장 인상깊었던 말은, "~ 같아요. ~라고 들었어요." 와 같은 말은 엔지니어와 맞지 않는 다는 말이었다. 일상 생활과 회사에서 너무나도 자주 쓰는 말이었는데, 조금씩 고쳐가야겠다. 

또, 발표를 할때, 해당 기술에 대해 기본적인 지식을 먼저 설명하고, 이 기술의 목적과 철칙이 어떤 것이고, 그래서 어떻게 사용해야 하는지에 대해 발표하는 것이 좋다는 이야기였다. 너무 도움이 되는 말이었다. 내가 발표를 잘 하지 못하는데, 오늘 들은대로 발표한다면, 어느정도 해소될 것 같다. 그리고 의사소통을 할 때에는 서로 공감되는 단어를 선택해서 의사소통을 해야 한다.

프로토타입을 만드는 이유는 리스크를 확인하기 위함이다. 



> 개인적으로 들은 피드백

1. OAuth에 대한 이해의 폭을 높히자. - OAuth에 대한 개념이 부족함. 처음 사용할 때가 해당 개념을 공부하기 가장 좋은 시기이다.

2. 이유가 없으면 안된다. - 내가 왜 네이버 로그인을 선택했을까? 정말 그냥이었는데, 이는 내가 선행되는 기술 조사를 하지 않았다는 것으로 이어진다. 무작정 구현하는 것 보다 생각을 먼저하자.
3. 클라이언트에서 OAuth 인증을 구현하면 클라이언트에서 라우팅 기능을 가지고 있어야하는 단점이 생긴다. 백엔드에서 인증을 할 경우, 클라이언트의 라우팅이 없어도 되므로 코드가 더 깔끔해진다.



**궁금한점**

서버에서 라우팅을 하면, 프론트에서 해당 경로의 파일을 어떻게 설정할 수 있을지? 이것도 react-dom-router 를 사용해서 구현해야 하는가? 그럼 기존의 클라이언트 인증과 다른점이 무엇인가?

---

## 2021.06.09

**미니 노션**

* slate-js 를 붙여서, 글자 블록 선택시 팝업 띄우고, 팝업의 버튼을 클릭해, bold, italic, underline 효과를 주는 것 까지 성공

기능만 추가한 상태라 코드가 아직 지저분 함. 

Portals를 사용하는 부분에 대해서 아직 공부가 더 필요하다고 느껴짐.

스타일 적용은 styled component를 사용해 작업할 예정. - 클래스 명을 지정해주지 않아도 되고, css 파일을 생성하지 않고도 style 속성을 줄 수 있는 장점이 있음.

---

## 2021.06.10

**우아한 테크러닝 4회차**

slatejs에 있는 예제를 추가했을 뿐인데, 결국 발표하게 되었다. 그리고 redux-thunk에 대해 내가 지금까지 잘 못 알고 있는 부분이었는데, 미들웨어 방식으로 동작하기 때문에 내가 따로 처리하는 부분을 작성해 주어야 했고, 리덕스로 액션을 날리기 전에 전 처리하는 구간이라고 생각하면 더 편할 것 같다. 나는 넣기만 하면 비동기를 추가해주는 것이라고 착각했었다.

그리고 CRA로 만든 앱에서는 slatejs의 match가 동작하는데, webpack config를 따로 설정한 앱에서는 match가 제대로 동작하지 않는다. 설정 부분에 무언가가 빠져있는 듯한데 다른 분 께서 TS의 `Generate` 가 제대로 동작하지 않는 것 같다는 말씀을 해주셔서 이부분에 대해 찾아봐야겠다. 그러면서 코드를 첨부해주셨는데

```typescript
const [bullet] = [
                ...Editor.nodes(editor, {
                  match: (n) => Element.isElement(n) && n.type === 'bullet',
                }),
              ];

```

이렇게 수정해 봤는데도 나는 동작을 안한다... 

그리고 교육 진행 방식이 변경된다. 아무래도 다들 직장인이고 바쁘기 때문에(~~나 루팡인거 들킴..~~) 남은 2주 간은 강의를 듣는 방식으로 진행될 것 같다.



그리고 발표를 잘하는 방법은 일단 내 머리에 있는 것을 글로 작성해보고, 이를 정리하는 것이다. 그리고 발표자료를 만들면 발표를 잘 할 수 있다고 조언해주셨다.



아직 MobX를 써보지는 않았는데, Redux보다 자유도가 높다고 한다. 언젠가는 나도 한 번 써봐야겠다. 근데 아직 리액트도 많이 부족하고, 리덕스는 더 부족해서, 어떻게 하면 실력을 더 늘릴 수 있을지 모르겠다 아직은.



컴포넌트 설계에 대한 부분도 굉장히 흥미롭게 들었다. bluePrint 라는 프레임워크에 대해 엄청 좋게 말씀하셔서 내일은 이 코드를 한 번 살펴봐야겠다.



오늘 느낀점은 첫 째로 내가 대충 알고 있는 것들이 너무 많다는 것이었다. 그리고 동작 원리에 대해 깊게 알려 하기 보다 그냥 실행 되면 되지 하는 마인드가 있다는 것을 느꼈다. 사실 위에 slatejs에 대한 부분도, CRA에서는 동작하니까 뭔가 설정 쪽에 문제가 있나보다 하고 나는 넘어갔을 텐데, 역시 고수들은 그 원인이 무엇인지에 더 관심을 두는 것 같다. 저런 자세를 배우고 싶은데 나도 변할 수 있을까?



한 주? 약간 길게 10일 정도 노션 과제를 하면서, 뭔가 하루종일 코딩에 대한 생각을 갖고 있게 되고, 주말에도 잠 줄여가면서 과제를 했는데 힘들다는 생각보다, 너무 재밌다! 라는 생각이 들었다. 우아한 형제들에서는 일하는 것도 이렇게 재밌을까? 의사 결정 과정과 더 좋은 코드를 만들기 위한 노력들이 너무 부럽다. 



**React**

오늘 slatejs 코드를 살펴보면서 Portal 과 forwardref에 대해 알게 되었다. 

둘이 비슷하면서도 다른데, Portal은 자식 컴포넌트를 외부에 렌더링하는 것이다. 그래서 외부에서 일어난 이벤트들을 부모가 알 수 있다. 

forwadref는 ref를 props로 받고, 그 ref에 자신의 엘리먼트를 주는 것이다. 그니까 부모 또는 다른 컴포넌트에게 자신의 엘리먼트를 조작할 수 있는 권한을 넘겨줄 때 사용한다.

---

## 2021.06.11

**sytled-components**

처음으로 styled-components를 사용해봤는데, 일단 첫 느낌은 너무 편하다는 점이었다. 따로 css 파일을 만들지 않아도 되는 것과, 한 파일에서 디자인과 기능적인 부분을 모두 다룰 수 있는 게 너무 좋았고, 리액트 특성상 컴포넌트 코드 내용이 그렇게 길어지지 않을 텐데, 그래서 같은 파일에 스타일적인 내용과 기능적인 내용을 모두 적어도 가독성이 전혀 떨어지지 않는 점이 리액트와 styled-components가 정말 찰떡이구나 라는 생각이 들었다. 

오늘은 styled-components를 미니 노션에 적용해 보았는데, 지금까지는 정말 만족한다. 오늘 배운 내용 하나를 조금 정리하자면, 외부 컴포넌트를 styled-components를 사용해 스타일을 적용하고 싶을 때는 아래 처럼 이용하면 된다.

```typescript
import { Editor } from 'sltae-react';
import style from 'styled-components'

const StyledEditor = style(Editor)`
	width: 25px;
	height: 30px;
	border: 1px solid #ddd;
`;

const MyEditor: React.FC = () => {
    return <StyledEditor />;
}
```



이렇게 작성하면, 외부의 Editor 컴포넌트를 다른 위치에서 스타일을 수정해 줄 수 있다. 물론 자신의 위치에서 props를 받아 스타일을 적용하는 것이 가장 좋지만, 외부 라이브러리 또는 패키지일 경우는 직접 해당 패키지를 수정해야 하고, 그러려면 해당 패키지에 styled-components를 적용하던가, 아니면 다른 css를 주입할 수 있는 방법을 적용해야 하기 때문에, 위의 방법을 사용하는 것이 더 편리하다고 생각한다.

---

## 2021.06.12

**미니 노션**

에디터 페이지의 사이드 메뉴를 만들어 봤다. 일단 로그아웃 버튼과 사용자의 이름과 사진을 띄워주는 것 까지 진행 되었고, 하단 내용은 서버에서 파일의 데이터베이스 모델을 어떻게 정의할지에 결정하고, 구현 후에 화면에 보여줄 예정이다.

내일은 일단 사이드 메뉴를 접는 기능을 추가하려 하고 있고, 리액트를 다루는 기술 책을 읽어가면서, 리액트 실력을 조금씩 늘려 갈 예정이다.

---

## 2021.06.13

**미니 노션**

사이드 메뉴 접었다 펴는 기능을 추가했다.



**TypeSciprt에서 react-router-dom의 withRouter 사용시 주의사항**

`props.history.push` 를 사용하려면 react router dom의 withRouter를 사용해서 컴포넌트를 반환해야 한다. 이 때 타입스크립트에서 props 인터페이스를 정의할 때, History 외의 다른 내용을 props 인터페이스에 정의하면 에러가 발생하고, 아래의 방법으로 해결할 수 있다.

```typescript
import { History } from 'history'
import { withRouter, RouteComponentProps } from 'react-router-dom'

interface Props {
    history: History;
    hover: boolean;
}

const userInfo: React.FC<Props & RouteComponentProps> = (props) => {
    // ...
}

export default withRouter(userInfo);
```



`interface Props` 내부에 history만 있으면 RouteComponentProps를 따로 사용하지 않아도 되지만, 만약 hover나 다른 내용이 있을 경우 RouteComponentProps를 사용해야 한다.

withRouter의 props 인터페이스에서 hover가 존재하지 않아 에러가 발생했고, 이를 위의 방법으로 피해갈 수 있다.

---

## 2021.06.14

**<a href="./react/Experience/Portal.md">Portal</a>**

리액트 트리는 변경하지 않고, DOM 트리에서 자식을 외부로 렌더링 하는 최고의 방법 중 하나는 Portal 이다. 공식 문서의 내용을 읽고 정리했고, Portal에 대해서는 이해했다는 생각이 든다.



**Typescript에서 리액트 클래스형 컴포넌트 사용하기**

Typescript를 사용해 리액트 클래스형 컴포넌트를 사용하려면, Props와 State 모두 interface를 정의하고 사용해야 한다.

```typescript
import { Component } from 'react'

interface Props {
    name: string;
    age: number;
};

interface State {
    count: number
};

class Person extends Component<Props, State> {
    state = {
        count: 1
    }
    
    render() {
        //...
    }
}
```

위처럼 사용해 줘야, setState를 할 때 ReadOnly 오류를 방지할 수 있다.

또한 State 선언할 때, constructor 내부에서 선언하지 않고, 위처럼 바로 state로 선언해줘도 된다.



**PropTypes 종류**

* array
* arrayOf(다른 PropTypes)
* bool
* func
* number
* object
* string
* symbol
* node: 렌더링 할 수 있는 모든 것(숫자, 문자열, JSX 코드)
* instanceOf(클래스)
* oneOf(배열)
* oneOfType([React.PropTypes.string, PropTypes.number])
* objectOf(React.PropTypes.number)
* shape({name: PropTypes.string, num: PropTypes.number})
* any



아 그리고 setState는 state값을 바로 변경시키지는 않음.

```tsx
<button
    onClick={() => {
        this.setState({number: this.state.number + 1});
        this.setState({number: this.state.number + 1});
    }}
>+1</button>
```

위처럼 코드를 작성하고, 버튼을 클릭했을 때, state.number의 값이 2씩 증가하지 않는다. 

이를 바로 적용하기 위해서는 아래처럼 setState에 매개변수를 줘야 한다.

```tsx
<button
    onClick={() => {
        this.setState(prevState => ({prevState.number + 1}));
        this.setState(prevState => ({prevState.number + 1}));
    }}
>+1</button>
```

setState의 콜백함수는 사실 매개변수를 하나 더 받을 수 있는데, 이는 props를 받고, 만약 props를 사용하지 않는다면 생략 가능하다.



setState 직후 다른 작업을 하기 위해서는 아래처럼 setState를 사용하면 된다.

```tsx
setState({number: number + 1}, () => console.log('방금 setState를 호출했습니다.'));
```

setState의 첫 번째 매개변수로 state 값을 변경시키고, 이후 파라미터로 콜백함수를 넣어 setState 직후의 작업을 추가할 수 있다.

---

## 2021.06.15

**우아한 테크러닝 5회차**

리액트에서는 완벽히 재사용 가능한 컴포넌트를 위한 기능을 제공하고 있지 않지만, 이를 보완하기 위한 여러가지 방법은 나와있다. 그 중 하나가 아토믹 디자인 시스템이다.



**리액트를 다루는 기술 4장. 이벤트 핸들링**

기본적인 내용을 이번에 다루었고, 리액트를 사용해 DOM에 이벤트를 등록하는 법을 배웠다. 

---

## 2021.06.16

**리액트를 다루는 기술 5장. ref: DOM에 이름 달기**

자바스크립트를 사용해 DOM 객체에 접근하기 위해서는 `<div id="root">` 와 같이 DOM 요소에 id를 붙여주고, `document.getElementById('root')` 를 사용해 접근했다. 이 때 id는 항상 유일한 이름을 가져야 한다.

리액트에서도 DOM에 접근해야 할 때가 있다. input 태그에 포커스를 주거나, 스크롤을 해야하거나 canvas에 그림을 그릴 때, DOM 객체에 접근해야 한다. 리액트에서도 위와 같이 id를 사용하는 방법을 쓸 수 있으나 그것보다 더 우아한 방법이 존재한다. 바로 `ref` 를 사용한 접근이다. ref는 컴포넌트 내에서만 동작하기 때문에, id보다 유일한 이름을 주기 쉽다. 

내 뇌피셜로는 ref는 VirualDOM 에서 ID 역할을 하고, Real DOM 에는 전달되지 않는 것이라는 생각이 들었고, 이에 대해서는 조금 더 알아봐야 할 것 같다.



어쨌든, 지금 주로 사용하는 함수형 컴포넌트에서는 useRef를 사용해서 ref를 사용하게 되는데, 오늘은 클래스형 컴포넌트에서 사용법을 다뤄봤다.

```jsx
<input ref={ref => {this.input = ref}} />
```

와 같이 DOM 요소 내에 ref를 콜백함수를 사용해 등록할 수 있다. 위의 경우 this.input 을 사용해 input 요소에 직접 접근할 수 있고, 위의 input 요소에 포커스를 주려면 `this.input.focus()` 와 같이 사용하면 된다.



또 한가지 방법은 creactRef 를 사용하는 방법인데 아래처럼 선언하고 사용할 수 있다.

```jsx
class Sample extends React.Component {
    input = React.createRef();
	
	// ...

	render() {
        <input ref={this.input} />
    }
}
```

createRef를 담을 변수를 하나 만들고, 이를 DOM 요소의 ref에 넣어주면 된다. 여기서 input 요소에 포커스를 주려면 `this.input.current.focus()` 와 같이 사용하면 된다. 주의할 점은 current를 한 번 써 주어야 한다는 것인데, 처음에 input 만 했을 때는 어느 DOM 요소에 ref가 달릴지 모르므로, current를 사용해주어야 한다.



추가로 Typescript에서 위의 방법으로 ref를 사용하려면 이렇게 사용하면 된다.

```tsx
<input ref={(ref: HTMLInputElement) => {this.input = ref}} />
```

위의 방법으로 선언하고 사용할 때는 아래의 방법으로 사용하면 된다.

```tsx
class Sample extends React.Component {
    input: (HTMLInputElement | null) = null;
    
    this.input?.focus();
}
```

input 뒤에 ? 가 있는 이유는 input이 null 일 수도 있기 때문에, null이 아닐경우 focus를 진행하는 의미이다.



위의 방법 중 createRef 를 사용하는 방법을 typescript 에서 사용하려면 아래 방법과 같다.

```tsx
class Sample extends React.Component {
    input: (HTMLInputElement | null) = null;
    
    this.input.current?.focus();
    
    render() {
        return <input ref={this.input}
    }
}
```

역시 current를 사용해 주어야 하고, 여기서는 current에 ?가 들어간다. input은 우리가 createRef를 했기 때문에 이미 값이 존재하는 상태이기 때문에 current가 null일 가능성이 있기 때문에 여기에 ?를 달아주어야 하는 것이 맞다.



**리액트를 다루는 기술 6장. 컴포넌트 반복**

이 장에서는 자바스크립트의 배열 api인 map에 대해 다루었다. 근데 내가 이번 장에서 배운 점은, onClick 이벤트나 onDoubleClick 이벤트는 기본적으로 `() => void` 형태이기 때문에 `onClick={(값) => {행동}}` 의 형태로 사용할 수가 없다. 만약 이 형태로 사용하고 싶을 경우 아래처럼 사용하면 된다.

```tsx
<li onDoubleClick={() => {onRemove(names.id)}} />
```

() => void 형태로 한번 감싸고 그 안에서 우리가 사용하고 싶은 형태를 사용해주면 된다.

---

## 2021.06.17

**우아한 테크러닝 6회차**

오늘은 리덕스를 만들어 보는 시간을 가졌는데, 생각보다 코드 양이 많지 않은 것에 놀랐고, 엄청 간단한 컨셉이라는 것에 또 놀랐다. 오늘 퇴근할 때 까지 리덕스랑 씨름을 했는데, 이 간단한 걸 어렵게 쓰고 있으니까 그랬던 것 같다.

클로저에 대해서도 중간에 설명을 들었는데, 나는 클로저는 알지 라고 자만했었는데, 클로저의 한 가지 측면만 알고 있었다. 클로저를 사용했을 때, 얻을 수 있는 효과로 함수 호출 지연, 이름을 지어서 가독성 향상이 있는데, 그저 내부 값을 외부에서 접근 하지 못하도록 하기 위한 것이라고만 알고있었다. 클로저에 대한 시선이 조금 더 넓어졌고, 자주 사용해야겠다는 생각이 들었다.

---

## 2021.06.18

**리액트를 다루는 기술 7장 8장**

7장에서는 클래스 형 컴포넌트에서 사용하는 생명주기 메서드를 다뤄보았고, 이를 사용해 에러 페이지를 만들 수 있다는 것을 알게 됐다. 

8장에서 훅에 대해 배우게 되었고, 타입스크립트에서 커스텀 제네릭 훅을 만드는 방법은 아래와 같다.

```tsx
// Arrow Function
const useInfo = <T>(initialState: T): [T, (e: React.ChangeEvent<HTMLInputElement) => void] => {
	// ...
	return [state, onChange];
}
          
// Normal Function
function useInfo<T>(initialState: T): [T, (e: React.ChangeEvent<HTMLInputElement>) => void] {
	// ...
    return [state, onChange]
}
```

---

## 2021.06.19

**리액트를 다루는 기술 9장**

9장에서는 컴포넌트를 스타일링 하는 방법에 대해 보게 되었다. 처음으로 일반적인 css 파일을 만들어 사용하는 것이 있는데, 작은 프로젝트의 경우, 클래스 이름이 중첩될 일이 별로 없기 때문에 이렇게 진행하는 것이 오히려 더 편할 것 같다는 생각이 들었다.

그리고 Sass인데 Sass는 Syntactically Awesome Style Sheets의 약자이다. 기존 css 문법과 거의 동일한데, 재사용할 수 있도록 지원을 해주고, 변수를 지정할 수 있어서 가독성도 높다. 사용법은 아래와 같다.

```scss
$red: #fa5252;
$orange: #fd7e14;
$yellow: #fcc419;
$green: #40c057;
$blue: #339af0;
$indigo: #5c7cfa;
$violet: #7950f2;

@mixin square($size) {
    $calculated: 32px * $size;
    width: $calculated;
    height: $calculated;
}

.box {
    @include square(1);
    background: $red;
}
```

$ 기호를 사용해 변수를 만들 수 있고, mixin 을 만든 후 `@include` 를 사용해서 이를 사용할 수 있다. 간편하고, 가독성도 좋다고 느껴졌는데, CRA 로 만든 프로젝트에서 사용하려면 `4.14.1` 버전을 사용해야 한다.



세 번째로는 요즘 굉장히 핫한 styled-components 를 사용해봤다. 기존 scss 또는 css와 문법적으로는 다를게 없다. 내가 생각하는 styled-components의 가장 큰 장점은 별도의 스타일 파일을 만들지 않아도 된다는 점이다. UI의 한 부분을 컴포넌트로 만드는 리액트와 굉장히 궁합이 잘맞는 느낌이고, 전역적으로 스타일을 설정할 수 있는 부분과, 별도의 클래스 명을 주지 않아도 되고, props를 사용해 스타일링을 진행할 수 있는 점이 굉장히 매력적으로 다가왔다. styled-components를 사용할 때, vscode-styled-components 익스텐션을 사용하려면 꼭 `import styled from 'styled-component'` 라고 선언해야 한다. styled 대신 style이나 다른 이름일 경우 익스텐션이 제대로 동작하지 않는다.

---

## 2021.06.20

**리액트를 사용하는 기술 10장 11장 12장 13장**

10장에서 일정 관리 앱 애플리케이션을 만들어 봤다. 기존에 클래스형 컴포넌트로 따라 만들어봤었는데, 이번에는 함수형 컴포넌트로 만들었다. React.Memo를 사용해서 변경사항이 있을 때만 렌더링 되도록 했다.



11장에서는 컴포넌트 성능 최적화를 진행했는데, 아직은 좀 이해하기 어려운 내용들이 많았다. useState로 만든 함수를 최적화 하기 위해서 기존에 `setValue(value + 1)` 이렇게 사용하는 부분을 `setValue(prevValue => prevValue + 1)` 이렇게 사용할 수도 있고, useReducer를 사용해도 같은 최적화(함수를 새로 만들지 않음)가 진행된다.

`react-virtualized` 를 사용한 렌더링 최적화도 있다. 이를 사용할 경우 스크롤 페이지에서 렌더링 최적화를 할 수 있다. 현재 보여지는 부분만 렌더링 하고, 화면에 보여지지 않는 부분은 렌더링 하지 않고, 공간만 확보를 해 놓는다.



12장에서는 immer를 사용해 객체 또는 배열의 불변성을 쉽게 유지하는 방법에 대해 배웠다. immer의 produce를 사용하면, 기존에 불변성을 유지하기 위해 사용했던 concat, filter, map 과 비구조화 할당을 하지 않고, push 등과 같은 api도 사용할 수 있다.



13장에서는 react-router-dom을 사용하는 시간을 가졌다. 기존에 왜 어디서는 `props.history.push('/')` 가 되고, 어디서는 이게 작동하지 않는 것에 대한 의문이 있었는데, react-router-dom 의 Route 컴포넌트 내부에 사용한 컴포넌트일 경우 위의 history가 제대로 동작한다. location, history, match가 react-router-dom 의 props로 들어가기 때문에 이를 사용할 수 있는데, Route에서 직접 사용한 컴포넌트가 아닐 경우 위의 3가지를 사용할 수 없다. 이때는 `withRouter` HOC 을 사용하면 똑같이 history, location, match 를 사용할 수 있게 된다.

---

## 2021.06.21

**리액트를 사용하는 기술 14장 ~~15장~~**

14장에서 axios 를 사용해 비동기적으로 외부 API를 사용하여 뉴스 데이터를 가져오고, 이를 화면에 뿌려주는 것에 대해 배웠다.

15장에서는 ContextAPI의 사용법에 대해 배웠는데, 나한테는 조금 어렵고 어색하게 느껴졌다. 일단 타입스크립트에서 제대로 적용하지 못해서 에러가 발생했는데, 지금 당장 이 개념이 필요한 것 같지는 않아서, 조금 나중에 다시 보려고 한다.

---

## 2021.06.22

**우아한 테크러닝 7회차**

이번 차시에서는 리덕스 미들웨어가 어떻게 동작하는지 직접 만들어보면서 익혔다. 커링 기법이 아직 익숙하지 않아서, 이해하기 힘들었는데, 코드를 자세히 보면서 다시 복습해야겠다는 느낌이 많이 들었다.

또 리액트가 어떻게 동작하는지에 대해서도 알아보는 시간을 가졌는데, 정말 높은 수준의 통찰력을 발표해주신 분과 민태님 모두 가지고 계신 것을 느꼈다. 아직 사용법을 익히기에 바쁜 나와 비교가 많이 되었고, 조금 더 본질에 다가가기 위한 공부의 중요성을 깨달았다.



**리액트를 다루는 기술 16장**

일반 바닐라 자바스크립트에서 리덕스를 사용하면서, 액션, 리듀서, 스토어, 디스패치, 구독에 대해 알아보았고, 이번 주 내내 보던 내용이라서 뭔가 익숙했다. 리덕스를 프로처럼 사용하고 싶은데, 아직 구조를 어떻게 잡는 것이 효과적일지에 대해 고민중이다.

---

## 2021.06.23

**REST API로 소셜 로그인 하기**

기존에 SDK를 사용하거나, 미리 만들어진 패키지를 사용해서 소셜 로그인을 만든 적은 있었는데, 처음부터 진행해본 적은 없었다.

OAuth 2.0 의 기본 단계는 우리의 서비스가 사용자에게 로그인을 요청하고, 사용자가 소셜로 로그인을 할 경우, 해당 소셜 서버에서 우리 서비스로 `인가 토큰` 을 발행한다. 우리는 이 인가 토큰을 가지고 다시 해당 소셜 서버에 `액세스 토큰`을 요청하고, 액세스 토큰을 받게 되면, 이를 사용해 `사용자 정보 또는 특정 기능` 을 사용할 수 있게 된다.

> 인가 토큰 -> 액세스 토큰 -> 로그인 한 것처럼 사용

크게 위의 순서로 진행된다.

---

## 2021.06.24

**우아한 테크러닝 8회차**

오늘은 제너레이터에 대한 설명을 듣고, 따라해봤다. 제너레이터는 이번에 처음 들어봐서, 제대로 따라가기는 힘들었지만, 기본 개념은 어려운 개념이 아니라는 느낌을 받았다. 일단 제너레이터 함수 내부와 외부에서 서로 커뮤니케이션 할 수 있고, 제너레이터 함수 내부에서는 무한 루프를 사용해도, 일단 yield를 만나면 멈춰있는 상태이기 때문에 에러가 발생하지 않는다.



4주 동안의 꿈 같았던 우아한 테크러닝이 끝났다. 서비스 업체를 주도하는 우아한 형제들에서 교육을 받을 수 있어서 정말 영광이었고, 너무 즐거웠다. 처음에 노션 만드는 것이 끝까지 갔다면 어땠을까 라는 아쉬움도 조금 있었지만, 다음에도 또 교육을 받고 싶은 아쉬움 정도인 것 같다. 민태님 뿐 아니라, 다른 참가자 분들께도 많이 배우는 시간이 되었고, 내 부족한 부분, 그리고 엔지니어로서 가져야할 자세에 대해 더 생각해보는 시간이었다. 



**리액트를 다루는 기술 17장**

리액트 앱에서 리덕스를 사용하는 방법에 대해 다뤘다. 주요 내용은 타입스크립트에서 리덕스를 사용하려면, RootReducer의 타입을 알아야 제대로 사용할 수 있기 때문에, combineReducers를 사용했다면 `export Type RootReducerState = ReturnType<typeof RootReducer` 이렇게 타입을 익스포트 해주고, 외부에서 상태를 가져와야 할 때, 이 타입을 사용해야 한다.

또 리덕스의 connect 함수를 사용할 경우 해당 컴포넌트의 부모 컴포넌트가 리렌더링 될 때, 자기 자신은 props가 변하지 않았다면, 리렌더링 되지 않는다. 하지만 useSelector를 사용하면 부모 컴포넌트가 리렌더링 될 때, 자기 자신도 리렌더링 되기 때문에 `React.memo` 를 사용해야 한다.

```react
export default React.memo(SelectorContainer);
```

---

## 2021.06.25

**<a href="./OAuth/소셜 로그인 - 인가 토큰 받아오기.md">구글, 네이버, 카카오 인가 토큰 받기</a>**


---


## 2021.06.26 ~ 2021.06.27

**리액트를 사용하는 기술 18장 中 redux-thunk**

Redux-Thunk를 사용하면서 삽질을 계속해서 이틀이나 잡고 있었다. 문제는 리덕스 미들웨어를 사용할 때, 순서에 맞게 사용한다는 것을 내가 간과했기 때문이었는데, 리덕스 미들웨어는 항상 앞에서 부터 순서대로 실행되기 때문에, 함수의 위치가 중요하다. 나는 redux-logger와 redux-thunk 두 개의 미들웨어를 사용했는데, redux-thunk를 logger 보다 앞에 두면, thunk에서 먼저 함수형 액션을 처리한 후, logger가 수행되기 때문에, logger가 함수형 액션을 기록하지 못한다.

logger에서 함수형 액션을 기록하기 원한다면, 또는 모든 리덕스 기록들을 출력하려면, applyMiddleware의 가장 마지막 인자로 logger를 넣어주어야 한다.

---

## 2021.06.28

**Redux-Saga**

리덕스 사가는 비동기를 처리에 도움을 주는 리덕스 미들웨어다. 제너레이터라는 구문을 사용하기 때문에 진입장벽이 다소 있는 편이다. 제너레이터를 간단히 소개하면, 함수를 실행 도중 멈출 수 있고, 함수의 바깥쪽과 커뮤니케이션을 할 수 있는 특수 함수이다. next를 사용해 한 단계씩 앞으로 전진해 나갈 수 있으며, 무한 루프가 허용되는 것이 대표적인 특징 중 하나다. 

사가에서는 여러가지 이펙트를 제공해주는데, 이를 사용하면 Redux-Thunk 보다 더 복잡한 작업을 쉽게 처리할 수 있다. 대표적으로 여러 번의 액션 중 마지막 액션만 처리해야 하는 경우 `takeLatest` 를 사용하면 된다.



리덕스 사가를 사용하면 좋은 상황은 아래와 같다.

* 기존 요청을 취소 처리해야 할 때(불필요한 중복 요청 방지)
* 특정 액션이 발생했을 때 다른 액션을 발생시키거나, API 요청 등 리덕스와 관계없는 코드를 실행할 때
* 웹소켓을 사용할 때
* API 요청 실패 시 재요청해야 할 때

---

## 2021.06.29

**CSS: !important**

---

## 2021.06.30

**리덕스 사가 튜토리얼**

핸드북에 있는 리덕스 사가 튜토리얼을 진행하면서, 가장 크게 느낀 점은 테스트하기 너무 쉽다는 것이었다. tape를 사용해서 테스트를 진행했고, 결과 UI 등이 너무 마음에 들었다. 

---

## 2021.07.01

**리액트를 사용하는 기술 18장 中 redux-saga**

어제 봤을 때는 그렇게 어렵지 않다는 생각이었는데, 확실히 타입스크립트를 같이 사용해보니, 진입장벽이 조금 높았다. 일단 redux-saga의 이펙트 중 하나인 call을 사용할 때, 타입을 어떻게 주어야 하는지에 대해 많이 고민했었고, 결국 api를 받아오는 부분에서, 비동기처리를 미리 한 후, 값을 넘기는 방법을 오늘은 사용했다. 근데 이렇게 하면 비동기 처리를 위해 리덕스 미들웨어를 사용하는 장점이 없어지는 것이 되기 때문에, Promise 타입을 주어야 하는지, 아니면 어떤 것을 주어야 하는지 아직 감이 안잡힌다. 일단 any를 줘도 안됐고, 특정 타입을 주어야 하는데, 이를 어떻게 해야 될 지 모르겠다.

---

## 2021.07.02

**리액트를 사용하는 기술 19장**

코드 스플리팅 기술에 대해 알아보았다. SPA의 경우, 사용하지 않는 컴포넌트들도 처음에 모두 가져오기 때문에, 초기 페이지가 나타나는데 시간이 SSR 보다 오래 걸린다는 단점이 있다. 이를 해결하기 위한 방법 중 하나가 코드 스플리팅인데, import 를 동적으로 한다는 것으로 보면 될 것 같다.

```javascript
import('./SplitMe').then(result => result.default());
```

자바스크립트에서는 위의 방식으로 진행할 수 있다.



리액트에서는 크게 두 가지 방법이 있는데, 클래스형 컴포넌트를 사용해서, state에 로드하는 것과 `React.laze` 와 `Suspense` 를 사용하는 것이다. 일단 클래스형 컴포넌트의 사용법은 아래와 같다.

```react
class App extends React.Component {
    state = {
        SplitMe: null
    }

	handleClick = async () => {
        const loadedModule = await import('./SplitMe');
        this.setState({
            SpliteMe: loadedModule
        });
    }
    
    render() {
        const {SplitMe} = this.state;
        return ({SplitMe && <SplitMe />});
    }
}
```

이 방법은 조금 귀찮은 작업이 들어간다. state를 추가해줘야 하고, 함수형 컴포넌트에서는 사용할 수 없다. 그리고 타입스크립트를 사용할 때는 state를 다음과 같이 정의해줘야 한다.

```typescript
interface IState {
    SplitMe: null | React.ComponentType;
}
```



두 번째 방법은 위의 방법과 거의 비슷하지만 조금 더 쉽다.

```react
const SplitMe = React.lazy(() => import('./SplitMe'));

function App() {
    return (
    	<Suspense fallback={<div>Loading...</div>}>
        	<SplitMe />
        </Suspense>
    );
}
```

`React.lazy` 와 `Suspense` 를 사용하면 로딩중에 보여줄 UI도 설정할 수 있다.



추가로 하나를 더 설명하자면, loadable component 라이브러리를 사용하는 것이다. loadable component 는 위의 두 방법에 추가적으로 preloading 과 서버 사이드 렌더링을 지원한다.

```react
import loadable from '@loadable/component';
const SplitMe = loadable(() => import('./SplitMe'), {fallback: <div>Loading...</div>});

function App() {
    const [visible, setVisible] = useState(false);
    // ...
    return (
    	{visible && <SplitMe />}
    );
}
```

방법이 `React.lazy ` 를 사용하는 것과 거의 똑같다. 여기서 프리 로딩을 사용하려면, `SplitMe.preload()` 를 호출하면 된다.

---

## 2021.07.03

**리액트를 다루는 기술 20장**

이번 장에서는 서버 사이드 렌더링에 대해 다뤘다. 그런데 아직 제대로 이해하지 못해서 서버 사이드 렌더링 부분은 따로 공부를 해야 할 것 같다. 프로미스를 배열로 집어넣고, 이를 다 수행하면 브라우저로 권한을 넘겨주는 것인지에 대해 궁금하고, 리덕스를 사용할 때도, 서버쪽에서 리덕스의 상태를 사용하다가 렌더링이 끝나면, 현재 상태 정보를 브라우저에게 넘겨주고, 이후 상태 관리는 브라우저에서 하는 것인지, 그리고 브라우저에서 상태 관리를 하다가, 다른 페이지(서버 사이드 렌더링이 적용되는)로 이동하게 되면 기존 상태는 보존 되는지가 궁금하다. 아직 이 궁금증이 풀리지 않았기 때문에 서버 사이드 렌더링은 깊게 공부해야 할 것 같다는 느낌이 들었다.

webpack 설정을 만져야 하는 부분이 까다로웠고, Express 를 사용하는 것은 흥미로웠다. 그럼 기존의 webpack-dev-server 는 아예 이용하지 않게 되는 것인가? 

이번 장을 보면서 궁금증만 더 커졌다.

---

## 2021.07.04

**리액트를 다루는 기술 21장**

Koa 프레임워크를 사용해 백엔드 서버를 만들어 보았다. Koa는 처음 사용해봤는데, 첫 느낌은 많이 가볍다는 느낌이었다. 근데 백엔드에서 라우터는 기본적으로 사용할 텐데, 이 부분을 굳이 라이브러리를 설치해서 사용하게 해야 했나? 라는 생각은 든다. 그래도 async/await 문법을 제대로 지원하기 때문에 조금 더 깔끔한 코딩을 할 수 있을 것이라는 생각이 들었고, 미들웨어를 next 로 호출할 때, 이 next가 Promise 객체를 반환하기 때문에, 다음 미들웨어를 수행한 뒤 작업을 처리할 수 있는 점은 큰 장점이라고 생각한다.

---

## 2021.07.05

**리액트를 다루는 기술 22장**

이번 장에서는 MongoDB를 연동해 블로그 포스트를 만드는 과정을 진행했다. MongoDB는 NoSQL로써, 일반 RDBMS와 구조가 다르다. RDBMS에서는 테이블 별로 분리해서 데이터를 처리했다면, MongoDB는 모든 것을 문서(RDBMS의 레코드와 비슷한 개념) 하나에 다 넣는다.

node env 환경변수 파일도 사용해봤는데, 굉장히 편리했다. 일단 `.env` 파일을 만들고, 해당 파일의 내용을 가져오려면 아래와 같이 사용하면 된다. 

```javascript
require('dotenv').config();

const {PORT} = process.env
```

추가로 env 파일을 사용하기 위해서는 `dotenv` 패키지를 설치해야 한다.



MongoDB를 연결하기 위해서 `mongoose` 패키지를 사용했다. 이를 사용하면 쉽게 연동할 수있고, API를 사용해 데이터를 쉽게 처리할 수 있다.

---

## 2021.07.06

**리액트를 다루는 기술 23장**

JWT를 사용해 회원 인증 시스템을 구현했다. 기존에 JWT는 써 본적이 있어서 사용법은 익숙했다. koa 프레임워크에서 미들웨어를 사용해 재사용성이 높은 코드를 작성하는 것이 인상깊었다.

---

## 2021.07.07

**<a href="https://chamy619.tistory.com/137">PG사 결제 프로세스</a>**

보통 결제 서비스를 제공하기 위해서는 PG사를 중간에 껴고 진행을 한다. 사용자 카드 정보와 같은 민감 정보를 우리가 처리하지 않기 위함과 실제 거래 부분을 PG사에서 대신 처리해주기 때문에 이용한다.

PG 사 API를 사용한 결제 시스템은 OAuth 소셜 로그인과 비슷하다. 첫 째로, 구매 금액, 상점 ID 등과 같은 정보를 PG 사로 보내 인증 토큰(access_token) 을 발급 받고, 이를 사용해 실제 거래 승인 요청을 전송한다. OAuth 에서 인가 토큰을 받는 과정이 빠진 버전이라고 이해하면 쉬울 것 같다.



**리액트를 다루는 기술 24장 中 회원가입**

블로그에 회원가입 기능을 추가했다. 아직 리덕스 사가 유틸 함수를 만드는 부분이 제대로 이해되지 않아서 그대로 따라친 느낌이 있다. 코드를 더 살펴보면서 진행해야겠다.

---

## 2021.07.08

**PG사 결제 중단 프로세스**

결제 중단이 되는 경우는 크게 두 가지로 나뉜다.

* 인증 단계에서 중단
* 승인 단계에서 중단

인증 단계에서 중단 될 경우, 크게 처리해야 할 것은 없다. 실질적인 거래가 이루어지지 않았기 때문에 거래는 자동 취소된다.

문제는 승인 단계에서 중단된 경우다. 만약 승인 요청을 보낸 후, 거래가 중단될 경우, 우리는 PG사로부터 결제 승인 응답을 받지 못했더라고, PG사와 원천사와의 거래는 이루어진다. 실제 고객의 카드에서 돈이 빠져나가고, 우리는 이를 알 수 없는 상황이 된다. 이 때는 **망취소** 요청을 전송해야 한다. 망취소 요청 주소는 인증 응답시 승인 요청 URL과 동시에 받을 수 있다.



**리액트를 다루는 기술 24장 中 로그인, 로그아웃**

새로고침시 로그인 상태를 유지하기 위해 localStorage에 로그인 사용자 정보를 저장했다. 그리고, 로그인 상태를 체크하는 함수를 `src/index.js` 파일에 작성했다. 이유는 화면 깜빡임을 방지하기 위해서다. index.js가 아닌 다른 컴포넌트에 넣을 경우, 체크 요청을 보내고, 응답을 받기 까지 약간의 시간 차이가 존재하는데, 이 시간은 화면을 렌더링하기에 충분한 시간이 될 수 있다. 따라서 로그인 상태에서 로그인 페이지에 접근하려 할 때, 원래대로라면, 로그인 페이지가 보이면 안되지만, 로그인 페이지가 잠깐 보여지고, 루트 페이지로 돌아가게 된다.

리덕스 사가를 사용했기 때문에, 체크하는 부분을 `sagaMiddleware.run(rootSaga)` 아래 부분에 넣어주어야 비동기 처리가 정확하게 일어난다.

---

## 2021.07.09

**리액트를 다루는 기술 25장**

이번 장에서는 Quill을 사용해서 에디터를 꾸미는 작업을 했다. Quill을 사용하는 법은 그냥 코드만 따라했다.

요즘 자꾸 코드를 따라하기만 하는 것 같은데, 이번 책이 얼마 안남았기 때문에, 모두 끝나면 마지막 프로젝트는 코드리뷰를 진행해야겠다. 이 때, 리덕스 구조가 어떻게 되어 있는지 파악하고, 리덕스 사가를 사용해 비동기 처리하는 부분을 유심히 보고, 회사 프로젝트에 적용해보도록 해야겠다.

---

## 2021.07.10

**리액트를 다루는 기술 26장**

헤더에 페이지네이션을 위한 마지막 페이지정보를 서버에서 넘겨줬는데, 이를 사용할 때, `meta` 라는 이름으로 받아서 사용했다. 그리고 서버에서 html 태그를 제외하고 값을 전달하기 위해서 `sanitize-html` 을 사용했다. 이를 사용하면 script 주입 공격을 막을 수 있다.

---

## 2021.07.11

**리액트를 다루는 기술 27장**

블로그 프로젝트를 완료했다. 일단 만드는 것의 50% 정도는 이해했고, 나머지 50% 정도는 따라치기 급급했다. 마지막에 빌드를 한 후, 서버에 접속해서 사용하는 부분도 더 공부해야될 것 같고, 리덕스 사가도 아직 익숙하지 않다. 일단 이후 공부 방향은 리덕스 사가를 조금 더 자세히 공부한 후, 배포하는 부분과, 서버사이드 렌더링 순으로 공부를 진행할 예정이다.

---

## 2021.07.12

**Replication vs Clustering**

수요일까지 이 부분에 대해 연구하고 문서화해야해서, 오늘은 이 부분만 찾아봤다. 프론트 파트를 맡고 있는데, 데이터베이스를 찾아보아야해서 모르는 단어 투성이라 많은 내용을 정리하지는 못했다.

일단 MariaDB는 MySQL에서 포크한 프로젝트다. 기존 MySQL 개발자가 MySQL을 나가서 새로 만든 것이 MariaDB이고, 따라서 초기 버전에서는 완전한 호환성을 제공했다. 추가로 MySQL의 엔터프라이즈 버전에서 사용할 수 있는 기능들을 MariaDB는 오픈소스이기 때문에 사용 가능한 경우가 있고, 성능 최적화도 더 많이 진행된 것으로 알려져있다.

일단 데이터 리플리케이션(replication)에 대해서 설명하자면, 일반적으로 Master - Slave 의 구조로 DB를 구축한다. Master는 쓰기 작업을 하고, Slave는 읽기 작업만 한다. 이 구조는 비동기방식이기 때문에, 일시적으로 Master의 데이터와 Slave의 데이터가 일치하지 않는 경우가 발생할 수 있다. 또한, Master가 죽었을 때, Slave 중 하나를 Master로 승격하는 작업이 필요하다.

리플리케이션의 문제를 해결하기 위해 클러스터링이란 방식이 등장한다. 클러스터링은 모든 노드들이 Master 역할을 한다. 클러스터링은 한 노드에서 쓰기 작업을 하게되면, 디스크에 내용을 쓰기 전에, 다른 노드에게 데이터 복제를 하라는 요청을 보내고, 다른 노드들이 복제 수락 응답을 보내면 그 때 실제 디스크에 쓰기 작업을 수행한다. 그리고 다른 노드에게 복제 완료 응답을 받으면 디스크에 데이터를 저장한다. 클러스터링은 항상 일관성있는 데이터를 얻을 수 있고, 노드가 죽어도 다른 노드들이 살아있으면 크게 문제가 발생하지 않는다는 장점이 있다. 리플리케이션의 단점을 완벽히 커버하는 장점이다. 하지만, 데이터를 쓸 때, 항상 복제 요청을 보내야하므로 쓰기 성능이 리플리케이션보다 떨어진다. 또한 새로운 노드를 추가할 때, 기존 데이터를 모두 복사해야하기 때문에 부하가 발생된다.

---

## 2021.07.13

**MySQL vs MariaDB**

MariaDB가 성능 최적화가 잘 되어 있다. 그리고 MySQL의 엔터프라이즈 버전에서만 사용할 수 있는 것들을 MariaDB는 순수 오픈 소스이기 때문에 제약 없이 사용할 수 있다. 하지만 기술 지원 측면에서 오라클의 24시간 전문가의 지원은 데이터베이스를 선택함에 있어서 큰 역할을 할 수 있다.

---

## 2021.07.14

**<a href="./Book/읽기 좋은 코드가 좋은 코드다/Chapter3.md">읽기 좋은 코드가 좋은 코드다 3장</a>**

**<a href="./Book/읽기 좋은 코드가 좋은 코드다/Chapter4.md">읽기 좋은 코드가 좋은 코드다 4장</a>**

두 장에서 오해를 일으키지 않는 이름의 중요성과 미학적인 부분에 대해 설명한다.



**<a href="./OAuth/OAuth 2.0.md">OAuth 2.0</a>**

---

## 2021.07.15

**<a href="./react/Velopert_React_Skill/Blog_Review_Authentication.md">리액트를 다루는 기술 회원 인증 리뷰</a>**

원래 회원 인증, 글 쓰기, 글 수정 및 삭제를 한 페이지에 작성하려 했는데, 막상 회원 인증을 작성하니 너무 길어져서 나눠서 쓰기로 결정했다. 그동안 그냥 따라 치기만 했었는데, 이렇게 코드를 다시 살펴보니까 배우게 된 점이 더 많았다. 리덕스 사가를 통해 비동기 api 호출하는 부분, 사가 유틸 함수 만드는 부분을 막연하게 이해했었는데, 이번 기회를 통해 확실하게 이해했다. 특히 사가 함수에 매개변수가 필요한데, 이 매개변수가 어디서 오는지 제대로 이해를 못했었다. 코드를 다시 보면서, 액션에 이 매개변수가 들어있는건데 왜 이해를 못했나 싶었다.

리뷰하는 것이 이미 한 번 짠 코드를 다시 보는 것이라서, 약간 귀찮은 과정이기도 하다. 하지만 이번 리뷰를 통해서 코드에 있는 오타를 잡을 수도 있었고, 코드를 내 것으로 만들 수 있었다. 귀찮더라도 리뷰는 꼭 하고 넘어가야겠다.

---

## 2021.07.16

**네이버 클라우드 계정 생성**

사내 프로젝트를 위해서 네이버 클라우드 계정을 생성했다. CentOS 를 사용할 계획이고, MariaDB 를 추가해서, 약간의 실습을 진행해봐야겠다.

---

## 2021.07.17

**Friend Wiki 백엔드 테스트 환경 구성**

jest 와 supertest 를 사용해서 테스팅 환경을 구축했다. 이제 테스팅 코드를 먼저 작성하고, 이후 코드를 작성하는 습관을 만들어보도록 할 계획이다.

---

## 2021.07.18

**dotenv 사용하기**

Node JS 를 사용하다보면 `process.env.PORT` 와 같이 특정 값에 접근하는 것들을 자주 볼 수 있다. 보통 포트 번호 또는 데이터베이스 URI, 클라이언트 시크릿 값들을 저렇게 숨겨놓고 사용한다.

사용법은 간단하다. 일단 dotenv 패키지를 설치한다.

```bash
yarn add -D dotenv
```



이후 프로젝트의 루트 디렉터리에 `.env` 파일을 만들고, 해당 파일에 자신이 사용하려는 내용을 작성한다.

```
PORT=4000
MONGO_URI=mongo.com
```



이제 이 값을 사용하려는 위치에서 아래와 같이 사용하면 된다.

```javascript
import dotenv from 'dotenv';

dotenv.config();

app.listen(process.env.PORT);
```

`dotenv.config()` 를 통해, 위에 작성한 파일의 내용을 가져오고, `process.env` 를 통해 값에 접근할 수 있다.

---

## 2021.07.19

**Friend Wiki - server: 회원가입 api**

회원가입 api 를 만들어봤다. 테스트 케이스도 추가했고, 회원가입 테스트 시 실제 데이터베이스에 회원이 추가되는데, 이를 테스트 코드에서 즉시 삭제하도록 설정해뒀다.

오늘 하면서 배운점은, body parser 를 사용할 때, 라우터 보다 먼저 사용해줘야 POST 의 body 를 제대로 읽을 수 있다는 점이다.

```
POST /api/auth/register
	email: string
	username: string
	password: string
```

---

## 2021.07.20

### Friend Wiki -server: 로그인, 로그아웃, 로그인 체크 api

#### 로그인

```
POST /api/auth/login
	email: string
	username: string
	password: string
```

```
{
	_id: string,
	email: string,
	username: string,
	__v: number
}
```

위의 요청을 보내면 아래의 응답을 얻을 수 있다. 응답을 보낼 때, 토큰을 발행한 뒤, 쿠키에 넣는다.



#### 로그아웃

```
POST /api/auth/logout
```

로그아웃 시 별도의 내용을 전송하지는 않는다.



#### 로그인 체크

```
GET /api/auth/check
```

```
{
	_id: string,
	email: string,
	username: string
}
```

쿠키 값으로 로그인 체크를 한다. 만약 로그인 되어있는 경우 로그인 계정의 id, email, 사용자 이름을 응답으로 보내준다. 만약 로그인 되어 있지 않다면 401 상태를 전송한다.

---

## 2021.07.21

**docker 설치**

---

## 2021.07.22

**Friend-Wiki: front 작업시작**

오늘은 로그인 화면을 만드는 작업을 진행했고, 로그인 api 전송하고 받는 부분까지 완료했다. 로그인 이후 페이지 이동하는 부분을 추가로 구현하고, 내일은 회원가입을 진행할 예정이다.

회원가입 시, 본인을 인증하는 질문을 하고, 이에 대한 답변을 받는 부분을 프론트 단에서만 하는 것이 좋을지, 백과 연동해서 하는 것이 좋을지 고민하고 있다. 프론트 단에서 진행하게 되면, 아무래도 질문 자체가 개발자 도구에 노출되는 점이 마음에 걸린다. 그런데 정말 간단한 로직인데, 굳이 서버와 통신을 통해 질문을 받아오고, 결과를 전송하는 것도 불필요한 통신을 하는 것 같아서, 이 부분에 대해 다른 사람들의 의견을 듣고싶다.

---

## 2021.07.23

**친구위키: 로그인 페이지**

로그인 페이지 작업을 완료했다. 원래 오늘 로그인에 회원가입까지 완료하려 했는데, 회원가입 api 연동을 아직 하지 못했다. 회원가입 api 연동과 회원가입 절차 중 친구들만 사용할 수 있도록, 문제를 만드는 기능을 추가해야 한다.

---

## 2021.07.24

**친구위키: 회원가입 페이지**

회원가입 페이지를 작업하던 중 문제가 발생했다. 회원가입 실패 상태와 로그인 실패 상태를 공유하기 때문에, 문제가 발생했는데, 지금 이 글을 쓰면서 생각해보니까, 해당 상태를 로그인에서만 사용하면 문제가 발생하지 않을 것 같다. 대박!!

---

## 2021.07.25

**JS: 객체**

`인사이드 자바스크립트` 라는 책을 구입해서, "3장 자바스크립트 데이터 타입과 연산자"를 읽었다. 그동안 몰랐던 부분은 

* 배열도 객체이기 때문에 `arr.name='hi'` 가 가능하다는 점 
* 배열의 프로토타입은 Array 이고, Array 의 프로토타입은 Object
* 객체에 length 프로퍼티가 있다면 이는 유사 배열 객체이기 때문에 `Array.prototype.push.apply(obj, ['hello'])` 처럼, apply 를 사용해 표준 배열 메서드를 사용할 수 있다는 점

크게 세 가지를 배울 수 있었다.

---

## 2021.07.27

**리액트 프로젝트 디렉터리 구조**

프레젠테이셔널 컨테이너 컴포넌트 구성 및 리덕스 리덕스 사가를 사용해 상태 관리를 할 때, 디렉터리 구조를 어떻게 가져가야 하는지에 대해 글을 작성했다. 회사 문서 공유사이트에 올려서 이를 직접적으로 공유하지는 못하나, components, containers, lib, modules, pages 의 크게 5 개의 디렉터리로 나누고, 프레젠테이셔널 컴포넌트는 components, 컨테이너는 containers, api 호출 또는 많은 곳에서 사용될 수 있는 함수는 lib, 리덕스 관련 부분은 modules 에 js 파일을 생성하고, pages 디렉터리에서는 실제 화면에 렌더링하는 컴포넌트를 가지고 있도록 구성했다.
